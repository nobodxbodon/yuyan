
寻标准库之书。
观标准库之书。

寻具体语法树之书。
观具体语法树之书。

寻抽象语法树之书。
观抽象语法树之书。
寻观抽象语法树方法之书。

寻内建操作符之书。
观内建操作符之书。

寻函数合集之书。

寻命名环境术之书。
观命名环境术之书。

寻操作符集术之书。
观操作符集术之书。

抽栈素立元类型也。

分析树者结构语法之语法分析树也。

表达式者抽象语法之表达式也。
观结构语法之书。

语者结构语法也。

观抽象语法之书。
栈素立元类型也。
    「： 栈关键字立化组件而栈素也。 ：」
    栈操作符立化操作符而化整数而栈素也。「：整数字符串组件的序号：」
    栈陌生字立化字符串而栈素也。
    栈分隔符立栈素也。 「：仅供临时使用，（仅可存在于栈头，不可存在于栈尾）：」
    栈绑定立化字符串而栈素也。
    「： 栈树立化分析树而栈素也。 纯分析树 ：」
    栈式立化表达式而栈素也。 「：纯分析树：」
    栈文件结尾立栈素也。「：EOF：」

栈素表示乃化栈素而字符串也。
栈素表示者
    会素而
    鉴素而
        有（栈操作符于符于序）则『操作符(』附（操作符表示于符）附『.』附（表示于序）附『)：』附（组件表示于（获取组件于符于序））附『|』
        或有（栈陌生字于串）则『陌生字：』附串附『|』
        或有（栈绑定于串）则『绑定：』附串附『|』
        或有栈文件结尾则『EOF』
        「： 或有栈树于树则『树：』附（结构语法表示之表示于树）附『|』 ：」
        或有栈式于式则『式：』附（抽象语法表示之表达式表示于式）附『|』
        或有「栈分隔符」则『分隔符|』
        或有「其他」则发生事故于『未有36』
    也。
栈表示乃化栈素列而字符串也。
栈表示者会栈而『（已反转）』附（以『··』合并（态射于栈素表示于（反转于栈）））也。

「：若匹配成功，则返回剩余输入：」
顶层匹配乃化分析树列而化字符串列「：单个字符：」而或可有（分析树列）也。
顶层匹配者循顶层匹配以会输入而会字列而鉴「字列」而
    有【】则可有（输入）
    或有「字列首」衔「字列尾」则
        （
            鉴输入而
            有（语之字符于输入字）衔输入尾则（
                若「字符串相等」于「字列首」于「输入字」
                则顶层匹配于输入尾于「字列尾」
                否则「可无」
                ）
            或有「其他」则「可无」
        ）也。

匹配操作符字符乃化分析树列「：输入：」而
                化操作符「：关键词所在操作符：」而
                化整数「：祖父穿组件序号：」而
                或可有（栈素合分析树列）「：如果顶层匹配成功，返回作为关键字的栈素以及之后的输入：」
                也。
匹配操作符字符者会输入而会操符而会序号而
    虑
    「
        关键词者获取组件字符串于操符于序号也。
        结果乃（或可有（栈素合分析树列））也。
        结果者鉴顶层匹配于输入于（获取字符于关键词）
        而有（可有（后输入））则可有（栈操作符于操符于序号与后输入）
        或有「可无」则「可无」
        也。
    」以成结果之道也。

扫描绑定乃化分析树列而化字符串而（或可有（栈素合分析树列））也。
扫描绑定者会输入而会截止而
    虑（
        处理括号表达式乃化分析树列「：括号内容：」而化分析树列「：括号后内容：」而（或可有（栈素合分析树列））也。
        处理括号表达式者会括号内而会括号后而
            若为纯名称于括号内则
                （鉴顶层匹配于括号后于（获取字符于截止）而
                    有（可有（余下输入））则（可有（（栈绑定于（获取纯名称于括号内））与括号后「：不可以使用余下输入因为仍然需要shift下个关键字：」））
                    或有（可无）则 （可无） 
                ）
            否则「可无」
            也。


        「：TODO：处理空字符串的情况：」
        扫描乃化分析树列而化字符串而（或可有（栈素合分析树列））也。
        扫描者循扫描以会当前输入而会累加而
            （鉴顶层匹配于当前输入于（获取字符于截止）而
                有（可有（余下输入））则（
                    若「串相等」于「累加」于『』
                    则（可无）「：绑定名称不可为空名称？：」
                    否则（可有（（栈绑定于「累加」）与当前输入））
                    ）
                或有（可无）则（鉴当前输入而
                    有（语之字符于输入字）衔输入尾则扫描于输入尾于（「累加」附输入字）
                    或有（语之方括号表达式于（语之连续表达式于「可能名称」））衔输入尾则
                        （若「串相等」于「累加」于『』
                        则处理括号表达式于「可能名称」于输入尾
                        否则（可无）「：名称必须一开始出现绑定，不可中途出现：」）
                    或有（语之圆括号表达式于（语之连续表达式于「可能名称」））衔输入尾则
                        （若「串相等」于「累加」于『』
                        则处理括号表达式于「可能名称」于输入尾
                        否则（可无）「：名称必须一开始出现绑定，不可中途出现：」）
                    或有「其他」则「可无」
                ）
            ）也。
    ）以成扫描于输入于『』之道也。


「：输入头部
    如果是字符则查询对应的关键字，可能有多个匹配项，
        若无匹配，则查询最长的不认识的名字：」
分析输入乃化「符列环境」而化栈素列而化分析树列而（栈素合分析树列）列也。
分析输入者会符列而会已有而会输入而
    虑「
        「： 打印行于『正在分析输入：』附（结构语法表示之「表示列」于输入）。 ：」
        关键词们者获取所有关键词于「符列」中零中零也。

        处理连续语句乃化分析树列而表达式也。
        处理连续语句者会语句而
            虑（
                粗者读引用于（「函数合集」之粗分析编译单元引用）于（结构语法之连续语句于语句）也。
                结构者读引用于（「函数合集」之抽象语法解析编译单元引用）于「符列」于粗也。
            ）以成（结构）之道也。
        「：仅仅看下一个字：」
        次字们者（（栈素合分析树列）列也（
            鉴输入而
                有【】则发生事故于『解析必须有值』
                或有 （语之字符于始）衔尾则（
                    虑「
                        可能解析者滤态射于（遇（操作符合整数）者甲而匹配操作符字符于输入于（甲中零）于（甲中一））于关键词们也。
                    」以成（
                        若「大于」于（长度于可能解析）于零
                        则可能解析
                        否则【（（栈陌生字于始与尾））】
                    ）之道
                ）
                或有（语之分隔符）衔尾
                    则（【（栈分隔符）与尾】）
                或有（语之圆括号表达式于（语之连续表达式于其他语））衔尾
                    则（【（栈式于
                        （（读引用于（「函数合集」之解表达式引用））于「符列」于其他语）「：直接递归编译其他语：」
                    ）与尾】）
                或有（语之字符串常量于串）衔尾则（
                        【（栈式于（抽象语法之式节点于（抽象语法之字符串节点于串）于【】））与尾】）
                或有（语之圆括号表达式于（语之连续语句于句））衔尾则（
                        【栈式于（处理连续语句于句）与尾】
                    ）
                或有（语之方括号表达式于（语之连续语句于句））衔尾则（
                        【栈式于（处理连续语句于句）与尾】
                    ）
                或有（语之方括号表达式于（语之连续表达式于式们））衔尾则（
                        【（
                            若（为纯名称于式们）
                            则栈式于（抽象语法之自由变量于（获取纯名称于式们））
                            否则（栈式于
                        （（读引用于（「函数合集」之解表达式引用））于「符列」于式们）
                        ））
                        与尾】
                    ）
                或有「其他2」则（发生事故于（『解表73：输入是』附（结构语法表示之「表示列」于输入）））
            ））也。
        「： 打印行于『完成次字分析』。 ：」
        绑定们乃（栈素合分析树列）列也。
        绑定们者
            鉴「已有」而
            有（栈操作符于整符于序号）衔尾则
                （
                    鉴（获取随后的绑定信息于整符于序号）而
                        有（可有（次字））则（
                            鉴（扫描绑定于输入于次字）
                            而有可有素则【素】
                            或有「可无」则【】）
                        或有（可无）则【】
                ）
            或有「其他」则【】也。
        投影名们乃（栈素合分析树列）列也。
        投影名们者
            鉴「已有」而
            有（栈操作符于整符于序号）衔（栈式于式）衔尾则
                （
                    若（序号等于（获取标号于（结构投影符）））
                    则（
                        鉴（计算可投影标签于「符列」于式）而
                            有（可有（标签们））则
                                滤态射于（会标签而
                                    鉴顶层匹配于输入于（获取字符于标签）而
                                        有（可有（余下输入））则（可有（栈式于（自由变量于标签）与余下输入））
                                        或有（可无）则（可无）
                                ）于标签们
                            或有（可无）则【】
                    ）
                    否则【】
                ）
            或有「其他」则【】也。
        总计者次字们接绑定们也。
        「： 打印行于『完成输入分析』。 ：」
    」以成总计之道也。




「： 
    单一操作符乃化栈素列而化分析树列而栈素列也。
    单一操作符者会栈而会输入而也。 
：」

移位规约结果立元类型也。
    结移位立化「符列环境」而化栈素列而移位规约结果也。「：规约，返回新的操作符列与新的栈列：」
    结规约立化「符列环境」而化栈素列而化栈素而移位规约结果也。「：规约，返回新的操作符列与新的栈列，输入应当保持不变：」
    结错误立移位规约结果也。

「：给定组件的操作符标号，栈（缩减且，反转过的）和组件，其中栈和组件必须是相同长度，
    若匹配成功，返回元素或绑定组件的参数，
    若匹配失败，返回可无：」
匹配组件获取参数乃化整数而化栈素列而化组件列而或可有（表达式列）也。
匹配组件获取参数者会符标号而会栈素们而会组件们而
    若（长度于栈素们）不等于（长度于组件们）
    则发生事故于『栈与组件长度必须相等』
    否则（
        从左折叠于（
                会素组而会当前参数而
                鉴当前参数而
                有「可无」则「可无」
                或有（可有「当前参数内容」）则（
                    鉴（栈素合组件也素组）而
                        有（栈操作符于栈整符于栈组序号）与（字符串组件于组符名）则
                            （若（「串相等」于（获取组件字符串于栈整符于栈组序号）于组符名）
                                    且（（获取标号于栈整符）等于符标号）
                                则可有（「当前参数内容」）
                                否则「可无」 ）
                        或有「其他」与（字符串组件于名）则「可无」
                        或有素与（绑定组件）则
                            （
                                鉴素而
                                有栈绑定于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                「：要做：这两项我们应该支持，但目前可能会产生多种唯一解
                                或许我们应该比较解析是否生成了结构相同的抽象语法树，
                                    如果是的话则可不报错：」
                                「： 或有栈陌生字于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                或有栈式于式则（可有（当前参数内容接【式】）） ：」
                                或有其他则「可无」「：注：是否要propogate原因？：」
                            ）
                        或有素与（元素组件于组优先）则
                            （「：COPY Paste：」
                                鉴素而
                                有栈绑定于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                或有栈陌生字于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                或有栈式于式则（可有（当前参数内容接【式】））
                                或有其他则「可无」「：注：是否要propogate原因？：」
                            ）
                        或有「其他」则（发生事故于『表192？』）
                ）
            ）于（可有【】）于（「拉链合并」于栈素们于组件们）
    ）也。



「：若规约成功，返回有，若规约失败，返回无：」
进行操作符规约乃化操作符而化栈素列而或可有（栈素列）也。
进行操作符规约者会符而会栈而
    虑「
        组件们者获取所有组件于符也。
        符标号者获取标号于符也。
        结果者若「大于」于（长度于组件们）于（长度于栈）
        则（或可有（栈素列）也「可无」）
        否则（
            虑（
            观抽象语法之书。
            栈素们者反转于（取于（长度于组件们）于栈）也。
            余下栈素者放于（长度于组件们）于栈也。
            参数乃或可有（表达式列）也。
            参数者匹配组件获取参数于符标号于栈素们于组件们也。

            结果乃或可有（栈素列）也。
            结果者（
                鉴参数而
                有「可无」则「可无」
                或有「可有「参数列」」则（
                    可有（（栈式于（获取阐述于符于「参数列」））衔余下栈素）
                ）
            ）也。
            ）以成结果之道

        ）也。
    」以成结果之道也。

进行一步规约乃化操作符列而化栈素列而或可有（栈素列）也。
进行一步规约者会可规约符列而会已有而
    虑「
        「： 打印行于『正在进行一步规约：标号：』附『当前栈：』附（栈表示于已有）附『「：换行：」   操作符』附（以『，』合并（态射于操作符表示于「可规约符列」））。 ：」
        
        可能规约者滤态射于
            （会符而进行操作符规约于符于已有
            ）于「可规约符列」也。
        结果乃（或可有（栈素列））也。
        结果者鉴「可能规约」而
        有【】则「可无」
        或有（唯一）衔【】则（可有（唯一））
        或有「其他」则发生事故于『多于一种理解』也。
    」以成结果之道也。


「：若无法规约，则返回原本的栈：」
进行所有可能规约乃化操作符列而化栈素列而栈素列也。
进行所有可能规约者循进行所有可能规约以会集而会已有而
    鉴（进行一步规约于集于「已有」）而
    有「可有（栈）」则（「进行所有可能规约」于集于「栈」）
    或有「可无」则（已有）
    也。


        「： 可规约符列者
            态射于（获取集操作符于集）于（「获取所有同等或更高优先级的操作符」于集于当前标号）也。 ：」


移位或规约一步乃化「符列环境」而化栈素列而化栈素而移位规约结果也。
移位或规约一步者会境而会已有而会次字而
    （
        虑符列者「符列环境读取操作符集」于「境」而
        鉴（已有与次字）而
        「：陌生字：」
        有【】与栈陌生字于串则结移位于「境」于（（栈陌生字于串）衔【】）
        或有（栈陌生字于词）衔栈尾与栈陌生字于字则结移位于「境」于（（栈陌生字于（词附字））衔栈尾）
        或有全栈与栈陌生字于字则结移位于「境」于（（栈陌生字于（字））衔全栈）
        「：分隔符：」
            「：下位不是陌生字，移除分隔符：」
        或有（栈分隔符）衔栈尾与下字则结规约于「境」于（栈尾）于次字
        或有（栈分隔符）衔栈尾与栈分隔符则结移位于「境」于（栈分隔符衔栈尾）
            「：仅当有陌生字时才使用分隔符划分，其余时候直接取消分隔符：」
        或有（栈陌生字于词）衔栈尾与栈分隔符则结移位于「境」于（栈分隔符衔（栈陌生字于（词））衔栈尾）
        或有全栈与栈分隔符则结移位于「境」于（全栈）
        「：普通操作符：」
        「：TODO进行规约后更新绑定信息？？？：」
        或有（栈）与（栈操作符于整符于组件序号）则
            （
            「： 虑无者打印行于『步骤0/6』 而 ：」
            虑规约后栈者（「：先进行规约：」
                （ 
                    若组件序号等于零 「：如果下个关键字是一个操作符的开始，那么规约所有闭合操作符：」
                    则（「进行所有可能规约」于
                        （态射于（获取集操作符于（「符列」））于（
                            「获取集所有闭合操作符」于「符列」
                        ）））于栈
                    否则（「进行所有可能规约」于
                        （态射于（获取集操作符于（「符列」））于（「：规约恰当的开放操作符及所有闭合操作符：」
                            鉴（第N个于（组件序号减一）于（获取所有组件于整符））
                            而有元素组件于「同等优先级」则「获取所有同等或更高优先级的操作符」于「符列」于（获取标号于整符）
                            或有元素组件于「更高优先级」则「获取所有更高优先级的操作符」于「符列」于（获取标号于整符）
                            或有元素组件于「重置优先级」则（态射于获取标号于（获取集所有操作符于「符列」））
                            或有绑定组件则（态射于获取标号于（获取集所有操作符于「符列」））
                            或有「其他」则发生事故于（『不可能的组件：299：』附（组件表示于「其他」））
                        ）））于栈
                        ））而
            「： 虑无者打印行于『步骤1/6』 而 ：」
            虑「可以移位」者（「：组件序号也是组件前面的元素个数：」
                    若（长度于规约后栈）小于组件序号「：栈上没有足够多的元素：」
                    则（阴）
                    否则（
                        虑组件们者取于（组件序号）于（获取所有组件于整符）而
                        虑栈素们者反转于（取于（组件序号）于规约后栈）而
                        有吗于（匹配组件获取参数于（获取标号于整符）于栈素们于组件们）
                    ）
                        ） 而
            「： 虑「不要」者（打印行于（若「可以移位」则『可以移位』否则『不可以移位』））而 ：」
            「： 虑无者打印行于『步骤2/6』 而 ：」
            若「可以移位」
                则（
                    「： 虑无者打印行于『步骤3/6』 而 ：」
                    虑新境者（（ 
                            若组件序号等于零 「：如果下个关键字是一个操作符的开始，那么规约所有闭合操作符：」
                            则（「境」）
                            否则（鉴（第N个于（组件序号减一）于（获取所有组件于整符））而
                                    有绑定组件则（ 鉴规约后栈而
                                        有（栈绑定于串）衔尾则（「添加声明」于「境」于「串」于（式节点于（元变量于内建元类型于内建元类型于（新引用于可无））于【】））
                                        或有「其他」则发生事故于『不可能在可规约的情况下前面的元素不是栈绑定』
                                    ）
                                    或有「其他」则（「境」）
                                ）））而
                    「： 虑无者打印行于『步骤4/6』 而 ：」
                    虑新栈操作符者（
                        若（（长度于（获取所有组件于（整符）））等于一）且（组件序号等于零）且
                            （鉴（第N个于组件序号于（获取所有组件于（整符）））而有字符串组件于串则阳或有「其他」则阴「：栈操作符应该一定是关键字：」）
                        则（栈式于（（获取阐述于（整符））于【】））
                        否则（栈操作符于整符于组件序号）
                    ）而
                    「： 虑无者打印行于『步骤5/6』 而 ：」
                    结移位于「新境」于新栈操作符衔规约后栈
                ）
                否则（结错误）
            ）
        「：绑定：」
        或有（栈）与（栈绑定于甲）则
            （结移位于「境」「：TOOD更新绑定：」于（（栈绑定于甲）衔（栈）））
        「：表达式：」
        或有（栈）与（栈式于式）则
            （结移位于「境」于（（栈式于式）衔（栈）））
        「：结束：」
        或有栈与栈文件结尾则结移位于「境」于（栈文件结尾衔（「进行所有可能规约」于（获取集所有操作符于「符列」）于栈））
        「：其他故障：」
        或有「其他」与输入则发生事故于（『豫言编译器/编译步骤/语法分析/表达式解析。豫:210 表达式解析遇到故障，在输入』
                    附（栈素表示于输入）附『「：换行：」当前栈是：』附（栈表示于「其他」））
        或有「其他」则发生事故于『解表91』
    ）也。

进行移位或规约乃化「符列环境」而化栈素列而化栈素而或可有（「符列环境」合栈素列）也。
进行移位或规约者循「进行移位或规约」以会符列而会已有而会次字而
    鉴（「移位或规约一步」于（「符列」）于已有于次字）而
        有结移位于「新符列」于甲则可有（（「新符列」）与甲）
        或有结错误则「可无」
        或有结规约于「新符列」于「后已有」于「后次字」则（「进行移位或规约」于（「新符列」）于后已有于后次字）
        或有「其他2」则（发生事故于『匹配失误100』）
        也。

「：一定会消耗输入：」
单一步骤乃化「符列环境」而化栈素列而化分析树列而化（化栈素列而有）而（「符列环境」合栈素列合分析树列）列也。
单一步骤者会符列而会已有而会输入而会调试而
    鉴输入而
    有【】则发生事故于『输入不可为空105』
    或有「其他」则（
        虑「
            「： 打印行于『正在执行单一步骤，输入是：』附（结构语法表示之「表示列」于输入）。 ：」
            输入解析者分析输入于「符列」于已有于输入也。
            结果者滤态射于（会甲而
                鉴（（栈素合分析树列）也甲）而
                有次字与剩余输入则
                                （
                                
                                鉴（
                                    「： 虑无者打印行于『移位规约开始』 而 ：」
                                    虑结果者「进行移位或规约」于（「符列」）于已有于次字而
                                    「： 虑无2者打印行于『移位规约完成』而 ：」
                                    结果）而
                                有（可有「新已有」）则（或可有（「符列环境」合栈素列合分析树列）也
                                        可有（（新已有中零）与（新已有中一）与剩余输入））
                                或有（可无）则（调试于（次字衔已有「：栈永远是反着的，打印时顺序会颠倒：」）
                                            ；可无）

                                ）
                或有「其他2」则（发生事故于『匹配失误116』）
                                ）
            于输入解析也。
            「： 打印行于『执行单一步骤完成』。 ：」
        」以成结果之道
    ）也。

「：每一个栈素代表一个唯一解：」
所有步骤乃化「符列环境」而化栈素列而化分析树列而化（化栈素列而有）而栈素列也。
所有步骤者循所有步骤以会符列而会已有而会输入而会调试而
    鉴输入而
    有【】则
    （鉴（「进行移位或规约」于（「符列」）于已有于（栈文件结尾））而
        有可有（「符」与「全栈」）则（
            鉴全栈而
                有栈文件结尾衔（栈式于式）衔【】则【栈式于式】
                或有栈文件结尾衔（栈陌生字于串）衔【】则【栈陌生字于串】
                或有「其他」则（调试于「其他」；【】）「：解析失败：」
        ）
        或有「可无」则【】
    ）
    或有「其他」则（
        虑（
            下步者单一步骤于「符列」于已有于输入于调试也。
            结果者串联于（态射于（会甲而
                    鉴（（「符列环境」合栈素列合分析树列）也甲）而
                        有（「下步符列」与下步已有与下步余入）则
                                （所有步骤于「下步符列」于下步已有于下步余入于调试 ）
                        或有「其他2」则（发生事故于『匹配失误』）
                                ）
                于下步）也。
        ）以成结果之道
    ）也。
    
「：注：可能要加入背景操作符列：」
进行解析乃化「符列环境」而化分析树列「：输入：」而表达式也。
进行解析者会符列而会输入而
    虑（
        「： 打印行于（『表达式解析：进行解析：』附（结构语法表示之「表示列」于（输入）））。 ：」
        失败解析乃引用类于（栈素列列）也。
        失败解析者新引用于【】也。

        调试乃化栈素列而有也。
        调试者会列而写引用于失败解析于（「列」衔（读引用于失败解析））也。



        结果乃表达式也。
        结果者尝试运行于（会不要而鉴（所有步骤于（「符列」）于【】于输入于调试）而
                        有【】则
                            发生事故于（『无法解析，可能的理解：「：换行：」』附
                                    （以『，「：换行：」』合并（态射于栈表示于（读引用于失败解析））））
                            附『「：换行：」输入是：』附（结构语法表示之「表示列」于输入）
                            附『「：换行：」环境：』附（「符列环境表示」于「符列」）
                        或有唯一解衔【】则
                            （ 鉴唯一解而
                                有栈陌生字于串则（抽象语法之自由变量于串）
                                或有栈式于式则（式）
                                或有栈绑定于串则（发生事故于『单一绑定于栈上：不可能』）
                                或有栈文件结尾则（发生事故于『不可能352』）
                                或有「其他」则（发生事故于『未有353：操作符于间隔符？「：换行：」结果：』附（栈表示于【「其他」】）
                                                        附『输入：』附（结构语法表示之「表示列」于「输入」））
                            ）
                            「： 发生事故于（『无法解析，可能的理解：「：换行：」』附
                                    （以『，「：换行：」』合并（态射于栈表示于【【唯一解】】））） ：」
                        或有「多种解法」则
                            （
                                虑「所有可能表达式」者（滤态射于（会解而（ 鉴解而
                                    有栈陌生字于串则可有（抽象语法之自由变量于串）
                                    或有栈式于式则可有（式）
                                    或有「其他形式」则（可无）
                                ））于「多种解法」）而
                                （
                                    若（长度于「所有可能表达式」）不等于（长度于「多种解法」）
                                    则发生事故于『不可能』
                                    否则（
                                        「：移除重复太慢，不可取：」
                                        「： 虑所有非重复解法者移除重复于（抽象语法相等之表达式相等）于「所有可能表达式」而 ：」
                                        虑所有非重复解法者「所有可能表达式」而
                                        （鉴「所有非重复解法」而
                                        有一式衔【】则一式
                                        或有「多种」则
                                            （
                                                发生事故于『多于一个解法：「：换行：」』附
                                                （以『「：换行：」』合并（态射于（抽象语法表示之表达式表示）于（所有非重复解法）））附『「：换行：」输入是：』附（结构语法表示之「表示列」于输入）
                                                附『「：换行：」环境：』附（「符列环境表示」于「符列」）
                                            ）
                                        ）
                             
                                ）
                            ）
            ））
            于（会错误信息而
                发生事故于（『遇到错误！』附错误信息附
                （『「：换行：」「：换行：」可能的理解：「：换行：」』附
                        （以『，「：换行：」』合并（态射于栈表示于（读引用于失败解析））））
                附『「：换行：」输入是：』附（结构语法表示之「表示列」于输入）
                附『「：换行：」环境：』附（「符列环境表示」于「符列」））
            ）
        也。
    ）以成结果之道也。

解表达式乃化「符列环境」而化分析树列而表达式也。
解表达式者会符列而会「树列」而
（（进行解析于「符列」于「树列」）
    「： 打印行于（『正在解析：』附（结构语法表示之「表示列」于「树列」）） ； ：」
   
）
也。

写引用于「函数合集」之解表达式引用于解表达式。