
寻标准库之书。
观标准库之书。

寻具体语法树之书。
观具体语法树之书。

寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之书。
观抽象语法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树方法之书。

寻观豫言编译器之编译数据之操作符之操作符操作之书。

寻函数合集之书。

寻观豫言编译器之编译数据之抽象绑定树结构之符列环境术之书。
寻观豫言编译器之编译数据之抽象绑定树结构之命名环境术之书。

寻观豫言编译器之编译数据之操作符之操作符集术之书。

寻观豫言编译器之编译数据之抽象绑定树结构之模块操作之书。
寻观豫言编译器之编译数据之操作符之操作符数据结构之书。

寻观豫言编译器之编译数据之编译配置之编译期输出之书。


抽栈素立元类型也。

分析树者结构语法之语法分析树也。

表达式者抽象语法之表达式也。
观结构语法之书。
语者结构语法也。


「：若匹配成功，则返回剩余输入：」
「：分隔符的问题需要讨论，目前顶层匹配会忽略分隔符：」
顶层匹配乃化分析树列而化字符串列「：单个字符：」而或可有（分析树列）也。
顶层匹配者循顶层匹配以会输入而会字列而
    鉴「字列」而
        有【】则可有（输入）
        或有「字列首」衔「字列尾」则
            （
                鉴输入而
                有（语之分隔符）衔「输入尾」则（
                     顶层匹配于输入尾于「字列」
                ）
                或有（语之字符于「输入字」）衔「输入尾」则（
                    若「字符串相等」于「字列首」于「输入字」
                    则顶层匹配于输入尾于「字列尾」
                    否则「可无」
                    ）
                或有「其他」则「可无」
            ）也。

匹配操作符字符乃化「符列环境」「：当前环境：」而
                化分析树列「：输入：」而
                化操作符「：关键词所在操作符：」而
                化整数「：字符串组件序号：」而
                或可有（栈素列合分析树列）「：如果顶层匹配成功，返回作为关键字的栈素以及之后的输入：」
                也。
匹配操作符字符者（会境而会输入而会操符而会序号而
    虑
    「
        关键词者获取操作符组件字符串于操符于序号也。
        结果乃（或可有（栈素列合分析树列））也。
        结果者鉴顶层匹配于输入于（获取字符于关键词）
        而有（可有（后输入））则可有（【栈操作符于境于操符于序号】与后输入）
        或有「可无」则「可无」
        也。
        结果。
    」）也。

「：扫描绑定返回绑定式和下一个字符串组件：」
扫描绑定乃化分析树列而化组件而化栈素而（或可有（栈素列合分析树列））也。
扫描绑定者会输入而会截止而会截止栈素而
    虑（
        「处理括号表达式」乃化分析树列「：括号内容：」而化分析树列「：括号后内容：」而（或可有（栈素列合分析树列））也。
        「处理括号表达式」者（会括号内而会括号后而
            若为纯名称于括号内则
                （鉴顶层匹配于括号后于（获取字符于（读取组件字符串于截止））而
                    有（可有（余下输入））则（可有（【（栈绑定于（获取纯名称于括号内）），截止栈素】与余下输入））
                    或有（可无）则 （可无） 
                ）
            否则「可无」）
            也。


        「：TODO：处理空字符串的情况：」
        扫描乃化分析树列而化字符串而（或可有（栈素列合分析树列））也。
        扫描者循扫描以会当前输入而会累加而
            （鉴顶层匹配于当前输入于（获取字符于（读取组件字符串于截止））而
                有（可有（余下输入））则（
                    若「串相等」于「累加」于『』
                    则（可无）「：绑定名称不可为空名称？：」
                    否则（可有（【（栈绑定于「累加」）】与当前输入））
                    ）
                或有（可无）则（鉴当前输入而
                    有（语之字符于「输入字」）衔「输入尾」则扫描于输入尾于（「累加」附输入字）
                    或有（语之方括号表达式于（语之连续表达式于「可能名称」））衔「输入尾」则
                        （若「串相等」于「累加」于『』
                        则处理括号表达式于「可能名称」于输入尾
                        否则（可无）「：名称必须一开始出现绑定，不可中途出现：」）
                    或有（语之圆括号表达式于（语之连续表达式于「可能名称」））衔「输入尾」则
                        （若「串相等」于「累加」于『』
                        则处理括号表达式于「可能名称」于输入尾
                        否则（可无）「：名称必须一开始出现绑定，不可中途出现：」）
                    或有「其他」则「可无」
                ）
            ）也。

            扫描于输入于『』。
    ）也。


处理连续语句乃化「符列环境」而化分析树列而表达式也。
处理连续语句者会符列而会语句而
    虑（
        粗者读引用于（「函数合集」之粗分析编译单元引用）于（「结构语法」之连续语句于语句）也。
        结构者读引用于（「函数合集」之抽象语法解析编译单元引用）于「符列」于粗也。
        结构
    ）也。

 「：已经获取了一部分陌生字，持续获取直到陌生字结束：」
获取陌生字直到结束乃化「符列环境」而化分析树列而字符串合分析树列也。
获取陌生字直到结束者循获取陌生字直到结束以会符列而会剩余输入而
    鉴剩余输入而
        有【】则『』与【】
        或有（语之分隔符）衔尾则『』与尾
        或有（语之字符于始）衔尾则（
            虑关键词们者「获取所有关键词」于「符列」中零中零而
            虑可能解析者（滤态射于（遇（操作符合整数）者甲而匹配操作符字符于「符列」于剩余输入于（甲中零）于（甲中一））于（关键词们））
            而（
                若「大于」于（长度于可能解析）于零
                则『』与剩余输入
                否则（
                    虑递归结果者（获取陌生字直到结束于「符列」于尾）而
                    （始附（递归结果中零）） 与 （递归结果中一）
                ）
            ） 
        ）
        或有「其他」则 『』与剩余输入
        也。



「：匹配可以作为开始的操作符：」
处理下个字符开始乃化「符列环境」而化分析树列而（栈素列合分析树列）列也。
处理下个字符开始者循处理下个字符开始以会符列而会输入而
（
    鉴输入而
        有【】则【】
        或有 （语之字符于始）衔尾则（
            虑关键词们者「获取所有开始关键词」于「符列」中零中零而
            虑可能解析者（滤态射于（遇（操作符合整数）者甲而匹配操作符字符于「符列」于输入于（甲中零）于（甲中一））于关键词们）
            而（
                若「大于」于（长度于可能解析）于零
                则可能解析
                否则（
                    虑陌生字结果者（获取陌生字直到结束于「符列」于尾）而
                    【【栈陌生字于（始附（陌生字结果中零））】 与 （陌生字结果中一）】
                ）
            ） 
        ）
        或有（语之分隔符）衔尾
            则（处理下个字符开始于「符列」于尾）
        或有（语之圆括号表达式于（语之连续表达式于「其他语」））衔尾
            则（【【（栈式于
                （（读引用于（「函数合集」之解表达式引用））于「符列」于其他语）「：直接递归编译其他语：」
            ）】与尾】）
        或有（语之字符串常量于串）衔尾则（
                【【（栈式于（抽象语法之式节点于（抽象语法之字符串节点于串）于【】））】与尾】）
        或有（语之圆括号表达式于（语之连续语句于句））衔尾则（
                【【栈式于（处理连续语句于「符列」于句）】与尾】
            ）
        或有（语之方括号表达式于（语之连续语句于句））衔尾则（
                【【栈式于（处理连续语句于「符列」于句）】与尾】
            ）
        或有（语之方括号表达式于（语之连续表达式于「式们」））衔尾则（
                【【（
                    若（为纯名称于式们）
                    则栈式于（
                        虑纯名称者（获取纯名称于式们）而
                        若（（串长度于「纯名称」）大于零）
                        则抽象语法之自由变量于纯名称
                        否则（抽象语法之式节点于（抽象语法之空缺）于【】）
                        ）
                    否则（栈式于
                （（读引用于（「函数合集」之解表达式引用））于「符列」于式们）
                ））】
                与尾】
            ）
        或有「其他2」则（发生事故于（『解表73：输入是』附（结构语法表示之「表示列」于输入）））
    ）也。


「：匹配可以作为一个操作符后续的操作符，
也就是获取的新操作符组件必须可以消除前面的输入
，不可以添加新的组件：」
「：我们目前假设不存在连续的参数组件，TODO：探究可否放松该要求：」
处理下个字符后续乃化「符列环境」而化分析树列而（栈素列合分析树列）列也。
处理下个字符后续者循处理下个字符后续以会符列而会输入而
    （
        鉴输入而
            有【】则【】
            或有 （语之字符于始）衔尾则（
                    虑关键词们者「获取所有继续关键词」于一于「符列」中零中零而
                    虑可能解析者（滤态射于（遇（操作符合整数）者甲而匹配操作符字符于「符列」于输入于（甲中零）于（甲中一））于关键词们）
                    而（
                        若「大于」于（长度于可能解析）于零
                        则可能解析
                        否则（【】）
                    ） 
            ）
            或有（语之分隔符）衔尾
                则（处理下个字符后续于「符列」于尾）
            或有（语之圆括号表达式于（语之连续表达式于「其他语」））衔尾
                则（【】）
            或有（语之字符串常量于串）衔尾
                则（【】）
            或有（语之圆括号表达式于（语之连续语句于句））衔尾
                则（【】）
            或有（语之方括号表达式于（语之连续语句于句））衔尾
                则（【】）
            或有（语之方括号表达式于（语之连续表达式于「式们」））衔尾
                则（【】）
            或有「其他2」则（发生事故于（『解表73：输入是』附（结构语法表示之「表示列」于输入）））
        ）也。



「：输入头部
    如果是字符则查询对应的关键字，可能有多个匹配项，
        若无匹配，则查询最长的不认识的名字：」
分析输入乃化「符列环境」而化栈素列而化分析树列而化（化字符串而化栈素列而有）而（栈素列「：正顺序：」合分析树列）列也。
分析输入者会符列而会已有而会输入而会调试而
        虑「
            默认处理乃化有而（栈素列「：正顺序：」合分析树列）列也。
            默认处理者会无而
                「：查找下一个操作符在已有栈中的序数：」
                鉴（查找元素序数条件于（会素而鉴素而有（栈操作符于「先境」于「整符」于「序号」）则阳或有「其他素」则阴）于「已有」）而
                    有（可有（序数））则（「：序数表示栈顶到第一个操作符所要跳过的表达式的个数：」
                        若序数大于零则
                        （
                            「：序数必须是一，因为我们假设不存在两个连续的参数。两个连续的参数将会使得很多的优化都不可以执行。：」
                            若序数大于一
                            则发生事故于『栈上不应当存在连续表达式！』
                            否则（
                                    虑「
                                        获得可能操作符匹配结果乃化整数「：当前检查的字符串组件在已有栈中序数，
                                        根据单参数假设，序数必须指向一个字符串组件，
                                        组件的序数加二即是下个要匹配输入 （此处序数含义发生改变！有栈序数和组件序数）
                                        ：」而（栈素列合分析树列）列也。
                                        获得可能操作符匹配结果者循获得可能操作符匹配结果以会序数而
                                            鉴（第N个于序数于「已有」）而
                                                有（栈操作符于「先境」于「整符」于「序号」）则
                                                    （
                                                        虑无者非常详细调试打印行于（会无而『[D][D]正在匹配操作符，序数：』附（整数表示于序数）附『，操作符：』附（操作符表示于「整符」）附『，组件序号：』附（整数表示于序号））而
                                                        虑组件们者「获取所有组件」于「整符」而
                                                        「：取得输入组件的位置：」
                                                        若（序号加二）小于（长度于组件们）
                                                        「：下一个输入仍然是组件内部：」
                                                        则（虑下个组件者第N个于（序号加二）于组件们
                                                            而
                                                                若组件是字符串组件于（第N个于（序号加二）于组件们）
                                                                    则（鉴（匹配操作符字符于「符列」于输入于「整符」于（序号加二））
                                                                        而有（可有「结果」）则（结果衔（处理下个字符后续于「符列」于输入））
                                                                        或有「可无」则（处理下个字符后续于「符列」于输入）
                                                                        ）
                                                                    否则（「：下个字符是表达式，如果我们强制不可以出现连续的表达式参数，这个case是不可能的：」
                                                                        「： 处理下个字符开始于「符列」于输入 ：」
                                                                        发生事故于『组件中纯真连续的参数』
                                                                    ）
                                                            ）
                                                        否则（
                                                            若（序号加二）等于（长度于组件们）「：正好是这个组件的完结，我们去寻找上一个组件：」
                                                            则（
                                                                虑下个序数者（序数加（序号加一））
                                                                而若下个序数小于（长度于「已有」）「：栈中仍然存在上个组件：」
                                                                则（获得可能操作符匹配结果于下个序数）
                                                                否则（处理下个字符后续于「符列」于输入）「：栈中不存在上个组件：」
                                                            ）
                                                            否则（发生事故于『组件的长度不正确』）
                                                        ）
                                                    ）
                                                或有「其他栈操作符」则发生事故于『不可能285，期待栈操作符』也。


                                        获得可能操作符匹配结果于序数
                                    」
                                ）
                           
                        ）
                        否则（处理下个字符开始于「符列」于输入）「：序数等于零， 后面可以是任意表达式：」
                    ）
                    或有（可无）则（
                        若（长度于「已有」）大于零则
                        （
                            处理下个字符后续于「符列」于输入「：栈上有表达式，可以处理后续的字符：」
                        ）
                        否则（
                            处理下个字符开始于「符列」于输入「：我们刚开始，可以处理开始的字符：」
                        ））也。
        
        （栈素列「：正顺序：」合分析树列）列也
        「：正式处理：」
        鉴「已有」而
            有（栈操作符于「先境」于「整符」于「序号」）衔尾则「：我们默认栈操作符不是结尾，结尾操作符必须归一，所以本操作符后必须跟一个表达式：」
                （
                    鉴（「获取随后的绑定信息」于整符于序号）而
                        有（可有（次字））则（
                            鉴（扫描绑定于输入于次字于（栈操作符于「先境」于「整符」于（「序号」加二）））
                                而有可有「绑定及操素」则【「绑定及操素」】
                                或有「可无」则【】）「：绑定必须解析成功，否则报错：」
                        或有（可无）则（
                            默认处理于元
                        ）
                ）
       或有「其他已有」则（
            默认处理于元
       ）
        」也。


「： 
    单一操作符乃化栈素列而化分析树列而栈素列也。
    单一操作符者会栈而会输入而也。 
：」

移位规约结果立元类型也。
    结移位立化「符列环境」而化栈素列而移位规约结果也。「：规约，返回新的操作符列与新的栈列：」
    「：规约，返回新的操作符列与新的栈列，输入应当保持不变：」
    「： 结规约立化「符列环境」而化栈素列而化栈素而移位规约结果也。 ：」
    结错误立移位规约结果也。

「：给定组件的操作符标号，栈（缩减且，反转过的）和组件，其中栈和组件必须是相同长度，
    若匹配成功，返回元素或绑定组件的参数，
    若匹配失败，返回可无：」
匹配组件获取参数乃化整数而化栈素列而化组件列而或可有（表达式列）也。
匹配组件获取参数者（会符标号而会栈素们而会组件们而
    若（长度于栈素们）不等于（长度于组件们）
    则发生事故于『栈与组件长度必须相等』
    否则（
        从左折叠于（
                会素组而会当前参数而
                鉴当前参数而
                有「可无」则「可无」
                或有（可有「当前参数内容」）则（
                    鉴（栈素合组件也素组）而
                        有（栈操作符于「先境」于「栈整符」于「栈组序号」）与（字符串组件于「组符名」）则
                            （若（「串相等」于（获取操作符组件字符串于栈整符于栈组序号）于组符名）
                                    且（（获取标号于栈整符）等于符标号）
                                则可有（「当前参数内容」）
                                否则「可无」 ）
                        或有（栈操作符于「先境」于「栈整符」于「栈组序号」）与（特殊字符串组件于「组符名」于转）则
                            （若（「串相等」于（获取操作符组件字符串于栈整符于栈组序号）于组符名）
                                    且（（获取标号于栈整符）等于符标号）
                                则可有（「当前参数内容」）
                                否则「可无」 ）
                        或有「其他」与（字符串组件于名）则「可无」
                        或有「其他」与（特殊字符串组件于名于转）则「可无」
                        或有素与（绑定组件）则
                            （
                                鉴素而
                                有栈绑定于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                「：要做：这两项我们应该支持，但目前可能会产生多种唯一解
                                或许我们应该比较解析是否生成了结构相同的抽象语法树，
                                    如果是的话则可不报错：」
                                或有其他则「可无」「：注：是否要propogate原因？：」
                            ）
                        或有素与（元素组件于「组优先」）则
                            （「：COPY Paste：」
                                鉴素而
                                有栈绑定于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                或有栈陌生字于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                或有栈式于式则（可有（当前参数内容接【式】））
                                或有其他则「可无」「：注：是否要propogate原因？：」
                            ）
                        或有「其他」则（发生事故于『表192？』）
                ）
            ）于（可有【】）于（「拉链合并」于栈素们于组件们）
    ））也。

「：获取参数栈素列中首个字符串组件记住的环境，必须传入反转过的栈：」
获取规约前环境乃化栈素列而或可有「符列环境」也。
获取规约前环境者（会栈而
    虑可能先境们者滤态射于（会素而鉴素而有
        （栈操作符于「先境」于符于组号）则（可有「先境」）
        或有「其他」则（可无））于栈而
    鉴「可能先境们」而
        有【】则（可无）
        或有（头衔尾）则（可有头））也。

进行一次栈尾规约乃化「符列环境」而化栈素列而或可有（「符列环境」合（栈素列））也。
进行一次栈尾规约者会境而会栈而
    虑（
        顶栈整符者
            鉴栈而
                有（栈操作符于「顶先境」于「顶栈整符」于「顶组件序号」）衔「余下栈」则
                    「：如果栈顶不可能是prefix operator，：」
                    「顶栈整符」
                或有（栈式于「顶式」）衔（栈操作符于「顶先境」于「顶栈整符」于「顶组件序号」）衔「余下栈」则
                    「顶栈整符」
                或有「其他」则
                    （操作符也发生事故于『405无法进行栈尾规约』）也。

        观抽象语法之书。
        「符标号」者（获取标号于顶栈整符）也。
        组件们者获取所有组件于顶栈整符也。
        若「大于」于（长度于组件们）于（长度于栈）
            则（可无）
            否则（虑
                （
                    栈素们者反转于（取于（长度于组件们）于栈）也。
                    余下栈素者放于（长度于组件们）于栈也。
                    参数乃或可有（表达式列）也。
                    参数者（匹配组件获取参数于符标号于栈素们于组件们）也。

                    先境者（鉴（获取规约前环境于栈素们）而
                        有（可无）则境
                        或有（可有先境）则先境）也。

                    结果乃或可有（「符列环境」合栈素列）也。
                    结果者（
                        鉴参数而
                        有「可无」则（
                                非常详细调试打印行于（会无而『参数获取失败』）；
                            可无）
                        或有「可有「参数列」」则（
                                非常详细调试打印行于（会无而『参数获取成功』）；
                            （虑可能阐述者（
                                        尝试运行于（会无而
                                            获取阐述于顶栈整符于「参数列」
                                        ）于（会错误信息而
                                            发生事故于（
                                                错误信息
                                                    附『「：换行：」当前栈是：』附（「栈表示」于栈）
                                                    附『「：换行：」操作符是：』附（「操作符表示」于顶栈整符）
                                                    附『「：换行：」环境：』附（「符列环境表示」于境）
                                            ）
                                        ）
                                    ）而
                                鉴「可能阐述」而
                                    有（可有「阐述式」）则（可有（先境与（（栈式于「阐述式」）衔余下栈素）））
                                    或有「可无」则「可无」
                            ）
                        ））也。

                    结果
                ） 
            ）。
    ）也。
        
「：若规约成功，返回有，若规约失败，返回无：」
「：我们规约时会碰到一种情况
A 式 | B 且AB没有优先级关系，这种情况下就应该是 (A 式) B 还是 A (式 B)呢？
我们规约会选后者，首先检查 A的优先级没有比B高，
那么B会不会被移位是一个关键问题！如果我们发现B的优先级也没有A高，那么我们应该直接报错！
但是在这里，为了减少报错，
我们选择移位！之后在总体规约时就会变成A (式 B)。

本函数只进行可能规约并返回结果，不进行移位
：」
进行操作符规约乃化「符列环境」而化栈素列而化栈素而或可有（「符列环境」合（栈素列））也。
进行操作符规约者循进行操作符规约以会境而会栈而会符而
    虑递归者进行操作符规约而
    鉴符而
        有（栈操作符于「后后境」于「整符」于「组件序号」）则
            若（（长度于栈）小于二）
            则（可有（境与栈「：如果栈只有一个或没有元素，直接返回：」））
            否则
            （
                鉴栈而
                    有（栈操作符于「顶先境」于「顶栈整符」于「顶组件序号」）衔「余下栈」则
                        「：如果栈顶不可能是prefix operator，：」
                        （可有（境与栈））
                    或有（栈绑定于字）衔「余下栈」则
                        （可有（境与栈））
                    或有（栈式于「顶式」）衔（栈操作符于「顶先境」于「顶栈整符」于「顶组件序号」）衔「余下栈」则
                        若（「组件序号」等于零）
                            则（发生事故于『后续组件序号不应当等于零』）
                            否则（
                                若（（「顶组件序号」加二）不等于（长度于（获取所有组件于「顶栈整符」）））「：如果没到结尾，不规约：」
                                    则（可有（境与栈））
                                    否则（
                                        虑可以规约者
                                            （（存在吗于（会甲而甲等于（获取标号于「顶栈整符」））于（
                                                「：获得下个组件前的组件：」
                                                鉴（第N个于（组件序号减一）于（获取所有组件于整符））
                                                    而有元素组件于「同等优先级」则
                                                        「获取所有同等或更高优先级的开放操作符」于（境中零）于（获取标号于整符）
                                                    或有元素组件于「更高优先级」则「获取所有更高优先级的开放操作符」于（境中零）于（获取标号于整符）
                                                    或有元素组件于「重置优先级」则（（获取集所有开放操作符于（境中零）））
                                                    或有「其他」则发生事故于（『不可能的组件：299：』附（组件表示于「其他」））
                                            ）））而
                                        虑无者非常详细调试打印行于（会无而『检查可以规约：』附（爻表示于可以规约）附『，栈：』附（栈表示于符衔栈））而
                                        若可以规约
                                        则（
                                            鉴（进行一次栈尾规约于「顶先境」于栈）而
                                            有（可有「后先境及后栈」）则
                                                （递归于（后先境及后栈中零）于（后先境及后栈中一）于符）
                                            或有（可无）则
                                                （可无）
                                        ）否则（
                                            （可有（境与栈））
                                        ）
                                ）
                            ）
                    或有「其他栈」则发生事故于『栈的格式有问题』


            ）
        或有「其他」则发生事故于『不存在』也。
「： 
进行一步规约乃化「符列环境」而化操作符列而化栈素列而或可有（「符列环境」合栈素列）也。
进行一步规约者会境而会可规约符列而会已有而
    虑「
        可能规约者滤态射于
            （会符而进行操作符规约于境于已有于符
            ）于「可规约符列」也。
        结果乃（或可有（「符列环境」合栈素列））也。
        结果者鉴「可能规约」而
        有【】则「可无」
        或有「唯一」衔【】则（可有（唯一））
        或有「其他」则发生事故于『多于一种理解』也。
        结果
    」也。


「：若无法规约，则返回原本的栈：」
进行所有可能规约乃化「符列环境」而化操作符列而化栈素列而（「符列环境」合栈素列）也。
进行所有可能规约者循进行所有可能规约以会境而会集而会已有而
    鉴（进行一步规约于境于集于「已有」）而
    有「可有（境及栈）」则（「进行所有可能规约」于（境及栈中零）于集于（境及栈中一））
    或有「可无」则（境与已有）
    也。
 ：」

移位或规约一步乃化「符列环境」而化栈素列而化栈素列而或可有（「符列环境」合栈素列）也。
移位或规约一步者循移位或规约一步以会境而会已有而会次字们而
    （「：我们更新了次字匹配，匹配的次字永远可以移位：」
        虑符列者「符列环境读取操作符集」于「境」而
        虑递归者「移位或规约一步」而
        鉴（已有与次字们）而
        有全栈与（【】）则（可有（境与全栈））
        「：陌生字：」
        或有全栈与（（栈陌生字于字）衔「后次字们」）则递归于「境」于（（栈式于（自由变量于字））衔全栈）于后次字们
        「：绑定：」
        或有（栈）与（（栈绑定于甲）衔「后次字们」）则
            （递归于「境」「：绑定在操作符中更新：」于（（栈绑定于甲）衔（栈））于后次字们）
        「：表达式：」
        或有（栈）与（（栈式于式）衔「后次字们」）则
            （递归于「境」于（（栈式于式）衔（栈））于后次字们）
        「：普通操作符：」
        「：TODO进行规约后更新绑定信息？？？：」
        或有（栈）与（（栈操作符于「先境」于「整符」于「组件序号」）衔「后次字们」）则「：TODO 进行多次移位规约：」
            （
            鉴（进行操作符规约于境于栈于（栈操作符于「先境」于「整符」于「组件序号」））
                而有（可有「规约后境及规约后栈」）则
                    （ 
                        虑规约后境者规约后境及规约后栈中零而
                        虑规约后栈者规约后境及规约后栈中一而
                            （
                                虑新境及栈者（或可有（「符列环境」合栈素列）也
                                        若（（「：如果这个组件在末尾，就可以规约：」
                                            「：我们象保持的不变条件是：已有栈上的：」
                                            （组件序号等于（（长度于（获取所有组件于（整符）））减一））））
                                        则
                                            （
                                            鉴进行一次栈尾规约于「规约后境」于（（栈操作符于「先境」于「整符」于「组件序号」）衔规约后栈）而
                                                有（可有「后先境及后栈」）则（递归于（后先境及后栈中零）于（后先境及后栈中一）于后次字们）
                                                或有（可无）则（可无）
                                                ）
                                        否则（（
                                                鉴（获取组件于整符于组件序号）而
                                                有（特殊字符串组件于名于转）则（
                                                    虑后境及转后栈者转于（规约后境与规约后栈）而
                                                    虑后境者后境及转后栈中零而
                                                    虑转后栈者后境及转后栈中一而
                                                    递归于「后境」于（栈操作符于规约后境于整符于组件序号）衔转后栈于后次字们）
                                                或有「其他」则（
                                                    递归于「规约后境」于（栈操作符于规约后境于整符于组件序号）衔规约后栈于后次字们
                                                ）
                                            ））
                                    ）而
                                新境及栈
                            ）
                    ）
                或有（可无）则「可无」
            ）
        「：结束：」
        或有栈与（栈文件结尾衔【】）则
            （
                若（长度于栈）大于一
                则（
                    鉴进行一次栈尾规约于境于栈而
                    有（可有「后先境及后栈」）则（递归于（后先境及后栈中零）于（后先境及后栈中一）于次字们）
                    或有（可无）则（可无）
                ）否则
                可有（境与（栈文件结尾衔栈））
            ）
        「：其他故障：」
        或有「其他」与输入则发生事故于（『豫言编译器/编译步骤/语法分析/表达式解析。豫:210 表达式解析遇到故障，在输入』
                    附（栈表示于（反转于输入））附『「：换行：」当前栈是：』附（栈表示于「其他」））
        或有「其他」则发生事故于『解表91』
    ）也。

「： 进行移位或规约乃化「符列环境」而化栈素列而化栈素列而或可有（「符列环境」合栈素列）也。
进行移位或规约者循「进行移位或规约」以会符列而会已有而会次字们而
    鉴（「移位或规约一步」于（「符列」）于已有于次字们）而
        有结移位于「新符列」于甲则可有（（「新符列」）与甲）
        或有结错误则「可无」
        「： 或有结规约于「新符列」于「后已有」于「后次字」则（「进行移位或规约」于（「新符列」）于后已有于后次字） ：」
        或有「其他2」则（发生事故于『匹配失误100』）
        也。 ：」

「：一定会消耗输入：」
单一步骤乃化「符列环境」而化栈素列而化分析树列而化（化字符串而化栈素列而有）而（「符列环境」合栈素列合分析树列）列也。
单一步骤者会符列而会已有而会输入而会调试而
    鉴输入而
    有【】则发生事故于『输入不可为空105』
    或有「其他」则（
        虑「
            详细调试打印行于（会无而『正在执行单一步骤，输入是：』附（结构语法表示之「表示列」于输入）附『， 栈是』附（栈表示于「已有」））。
            输入解析者分析输入于「符列」于已有于输入于调试也。

            若（长度于输入解析）等于零则（调试于『无输入解析：』于「已有」）否则元。

            结果者滤态射于（会甲而
                    鉴（（栈素列合分析树列）也甲）而
                    有「次字们」与「剩余输入」则
                                    （
                                        鉴（
                                            虑结果者「移位或规约一步」于（「符列」）于已有于「次字们」而
                                            结果）而
                                        有（可有「新已有」）则（或可有（「符列环境」合栈素列合分析树列）也
                                                可有（（新已有中零）与（新已有中一）与剩余输入））
                                        或有（可无）则（调试于『无规约：』于（（反转于次字们）接已有「：栈永远是反着的，打印时顺序会颠倒：」）
                                                    ；可无）
                                    ）
                    或有「其他2」则（发生事故于『匹配失误116』）
                ）
            于输入解析也。

            结果
        」
    ）也。

「：返回可能得解：」
所有步骤乃化「符列环境」而化栈素列而化分析树列而化（化字符串而化栈素列而有）而表达式列也。
所有步骤者循所有步骤以会符列而会已有而会输入而会调试而
    鉴输入而
    有【】则
    （鉴（「移位或规约一步」于（「符列」）于已有于【栈文件结尾】）而
        有可有（「符」与「全栈」）则（
            鉴全栈而
                有栈文件结尾衔【】则【式节点于空缺于【】】
                或有栈文件结尾衔（栈式于式）衔【】则【式】
                或有栈文件结尾衔（栈陌生字于串）衔【】则【自由变量于串】
                或有「其他」则（调试于『全栈非单一表达式：』于「其他」；【】）「：解析失败：」
        ）
        或有「可无」则（调试于『无尾规约』于「已有」；【】）
    ）
    或有（语之分隔符）衔「输入尾」
        则（「所有步骤」于（「符列」）于已有于输入尾于调试）
    或有「其他」则（
        虑（
            下步者单一步骤于「符列」于已有于输入于调试也。
            结果者串联于（态射于（会甲而
                    鉴（（「符列环境」合栈素列合分析树列）也甲）而
                        有（「下步符列」与下步已有与下步余入）则
                                （所有步骤于「下步符列」于下步已有于下步余入于调试 ）
                        或有「其他2」则（发生事故于『匹配失误』）
                                ）
                于下步）也。
            
            结果
        ）
    ）也。
    
「：注：可能要加入背景操作符列：」
进行解析乃化「符列环境」而化分析树列「：输入：」而表达式也。
进行解析者会符列而会输入而
    虑（
        「： 打印行于（『表达式解析：进行解析：』附（结构语法表示之「表示列」于（输入）））。 ：」
        失败解析乃引用类于（栈素列列）也。
        失败解析者新引用于【】也。

        调试乃化字符串而化栈素列而有也。
        调试者会信息而会列而
            （虑无者（详细调试打印行于（会无而『分支解析失败，』附信息附『，栈：』附（栈表示于「列」）））而
            写引用于失败解析于（「列」衔（读引用于失败解析）
            ））也。


        结果乃表达式也。
        结果者尝试运行于（会不要而鉴（所有步骤于（「符列」）于【】于输入于调试）而
                        有【】则
                            发生事故于（『无法解析，可能的理解：「：换行：」』附
                                    （以『，「：换行：」』合并（态射于栈表示于（读引用于失败解析））））
                            附『「：换行：」输入是：』附（结构语法表示之「表示列」于输入）
                            附『「：换行：」环境：』附（「符列环境表示」于「符列」）
                        或有「唯一解」衔【】则
                            （唯一解）
                        或有「多种解法」则
                            （
                                
                                （
                                    发生事故于『多于一个解法：「：换行：」』附
                                    （以『「：换行：」』合并（态射于（抽象语法表示之表达式表示）于（多种解法）））
                                    附『「：换行：」输入是：』附（结构语法表示之「表示列」于输入）
                                    附『「：换行：」环境：』附（「符列环境表示」于「符列」）
                                ）
            ））
            于（会错误信息而
                发生事故于（错误信息）
            ）
        也。

        结果
    ）也。

解表达式乃化「符列环境」而化分析树列而表达式也。
解表达式者会符列而会「树列」而
    （进行解析于「符列」于「树列」）
也。

写引用于「函数合集」之解表达式引用于解表达式。