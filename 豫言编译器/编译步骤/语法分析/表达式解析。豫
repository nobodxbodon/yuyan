
寻标准库之书。
观标准库之书。

寻具体语法树之书。
观具体语法树之书。

寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之书。
观抽象语法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树方法之书。

寻观豫言编译器之编译数据之操作符之操作符操作之书。

寻函数合集之书。

寻观豫言编译器之编译数据之抽象绑定树结构之符列环境术之书。
寻观豫言编译器之编译数据之抽象绑定树结构之命名环境术之书。

寻观豫言编译器之编译数据之操作符之操作符集术之书。

寻观豫言编译器之编译数据之抽象绑定树结构之模块操作之书。
寻观豫言编译器之编译数据之操作符之操作符数据结构之书。

寻观豫言编译器之编译数据之编译配置之编译期输出之书。


抽栈素立元类型也。

分析树即结构语法之语法分析树也。

表达式即抽象语法之表达式也。
观结构语法之书。
语者结构语法也。


「：若匹配成功，则返回剩余输入：」
「：分隔符的问题需要讨论，目前顶层匹配会忽略分隔符：」
顶层匹配乃化分析树列而化字符串列「：单个字符：」而或可有（分析树列）也。
顶层匹配者循顶层匹配以会输入而会字列而
    鉴「字列」而
        有【】则可有（输入）
        或有「字列首」衔「字列尾」则
            （
                鉴输入而
                有（语之分隔符）衔「输入尾」则（
                     顶层匹配于输入尾于「字列」
                ）
                或有（语之字符于「输入字」）衔「输入尾」则（
                    若「字符串相等」于「字列首」于「输入字」
                    则顶层匹配于输入尾于「字列尾」
                    否则「可无」
                    ）
                或有「其他」则「可无」
            ）也。

匹配操作符字符乃化「符列环境」「：当前环境：」而
                化栈素列「：已有栈素，应当不会改变：」而
                化分析树列「：输入：」而
                化（操作符「：关键词所在操作符：」合整数「：字符串组件序号：」）列而
                （栈素列合栈素列合分析树列）列「：如果顶层匹配成功，返回作为关键字的栈素以及之后的输入：」
                也。
匹配操作符字符者（会境而会已有而会输入而会符序们而
    虑「
        匹配符序们者（滤态射于（会符序而
                        虑操符者二对子取零于符序而
                        虑序号者二对子取一于符序而
                        虑关键词者获取操作符组件字符串于操符于序号而
                            鉴顶层匹配于输入于（获取字符于关键词）
                                而有（可有「后输入」）则可有（关键词与（操符与序号）与后输入）
                                或有「可无」则「可无」
                    ）于符序们）也。

        「：把相同关键词的归为一组：」
        处理乃化（字符串合（操作符合整数）合分析树列）列而（栈素列合栈素列合分析树列）列也。
        处理者循处理以会待处理而
            鉴待处理而
                有【】则【】
                或有（「关键词」与（「操符」与「序号」）与「后输入」）衔「待处理尾」则
                    「：我们挑出处理尾中相同长度的关键词组件放在一起，剩余的再继续处理：」
                    （已有与（【栈操作符于境于（
                        （「操符」与「序号」）衔
                            （滤态射于（会项而
                                若（（串长度于关键词）等于（串长度于（三对子取零于项）））
                                则（可有（项中一））
                                否则「可无」
                            ）于待处理尾））】
                    ）与「后输入」）衔
                    （
                        处理于（
                            （滤于（会项而
                                （（串长度于关键词）不等于（串长度于（三对子取零于项）））
                            ）于待处理尾）
                        ）
                    ）也。
        处理于匹配符序们。
    」
    ）也。

「：扫描绑定返回绑定式和下一个字符串组件：」
扫描绑定乃化分析树列而化组件而化栈素而（或可有（栈素列合分析树列））也。
扫描绑定者会输入而会截止而会截止栈素而
    虑（
        「处理括号表达式」乃化分析树列「：括号内容：」而化分析树列「：括号后内容：」而（或可有（栈素列合分析树列））也。
        「处理括号表达式」者（会括号内而会括号后而
            若为纯名称于括号内则
                （鉴顶层匹配于括号后于（获取字符于（读取组件字符串于截止））而
                    有（可有「余下输入」）则（可有（【（栈绑定于（获取纯名称于括号内）），截止栈素】与余下输入））
                    或有（可无）则 （可无） 
                ）
            否则「可无」）
            也。


        「：TODO：处理空字符串的情况：」
        扫描乃化分析树列而化字符串而（或可有（栈素列合分析树列））也。
        扫描者循扫描以会当前输入而会累加而
            （鉴顶层匹配于当前输入于（获取字符于（读取组件字符串于截止））而
                有（可有「余下输入」）则（
                    若「串相等」于「累加」于『』
                    则（可无）「：绑定名称不可为空名称？：」
                    否则（可有（【（栈绑定于「累加」）】与当前输入））
                    ）
                或有（可无）则（鉴当前输入而
                    有（语之字符于「输入字」）衔「输入尾」则扫描于输入尾于（「累加」附输入字）
                    或有（语之方括号表达式于（语之连续表达式于「可能名称」））衔「输入尾」则
                        （若「串相等」于「累加」于『』
                        则处理括号表达式于「可能名称」于输入尾
                        否则（可无）「：名称必须一开始出现绑定，不可中途出现：」）
                    或有（语之圆括号表达式于（语之连续表达式于「可能名称」））衔「输入尾」则
                        （若「串相等」于「累加」于『』
                        则处理括号表达式于「可能名称」于输入尾
                        否则（可无）「：名称必须一开始出现绑定，不可中途出现：」）
                    或有「其他」则「可无」
                ）
            ）也。

            扫描于输入于『』。
    ）也。


处理连续语句乃化「符列环境」而化分析树列而表达式也。
处理连续语句者会符列而会语句而
    虑（
        粗者读引用于（「函数合集」之粗分析编译单元引用）于（「结构语法」之连续语句于语句）也。
        结构者读引用于（「函数合集」之抽象语法解析编译单元引用）于「符列」于粗也。
        结构
    ）也。

 「：已经获取了一部分陌生字，持续获取直到陌生字结束：」
获取陌生字直到结束乃化「符列环境」而化栈素列而化分析树列而字符串合分析树列也。
获取陌生字直到结束者循获取陌生字直到结束以会符列而会已有而会剩余输入而
    鉴剩余输入而
        有【】则『』与【】
        或有（语之分隔符）衔尾则『』与尾
        或有（语之字符于始）衔尾则（
            虑关键词们者「获取所有关键词」于「符列」中零中零而
            虑可能解析者匹配操作符字符于「符列」于「已有」于剩余输入于关键词们
            而（
                若「大于」于（长度于可能解析）于零
                则『』与剩余输入
                否则（
                    虑递归结果者（获取陌生字直到结束于「符列」于已有于尾）而
                    （始附（递归结果中零）） 与 （递归结果中一）
                ）
            ） 
        ）
        或有「其他」则 『』与剩余输入
        也。



「：匹配可以作为开始的操作符：」
处理下个字符开始乃化「符列环境」而化栈素列而化分析树列而（栈素列合栈素列合分析树列）列也。
处理下个字符开始者循处理下个字符开始以会符列而会已有而会输入而
（
    鉴输入而
        有【】则【】
        或有 （语之字符于始）衔尾则（
            虑关键词们者「获取所有开始关键词」于「符列」中零中零而
            虑可能解析者匹配操作符字符于「符列」于「已有」于输入于关键词们
            而（
                若「大于」于（长度于可能解析）于零
                则可能解析
                否则（
                    虑陌生字结果者（获取陌生字直到结束于「符列」于已有于输入）而
                    「：检查陌生字长度，如果没有陌生字，有可能字符“始”是中间的关键字，这时我们也不解析：」
                    若（（「串长度」于（陌生字结果中零））大于零）
                    则【「已有」与【栈陌生字于（陌生字结果中零）】 与 （陌生字结果中一）】
                    否则【】
                ）
            ） 
        ）
        或有（语之分隔符）衔尾
            则（处理下个字符开始于「符列」于已有于尾）
        或有（语之圆括号表达式于（语之连续表达式于「其他语」））衔尾
            则（【已有与【（栈式于
                （（读引用于（「函数合集」之解表达式引用））于「符列」于其他语）「：直接递归编译其他语：」
            ）】与尾】）
        或有（语之字符串常量于串）衔尾则（
                【已有与【（栈式于（抽象语法之式节点于（抽象语法之字符串节点于串）于【】））】与尾】）
        或有（语之圆括号表达式于（语之连续语句于句））衔尾则（
                【已有与【栈式于（处理连续语句于「符列」于句）】与尾】
            ）
        或有（语之方括号表达式于（语之连续语句于句））衔尾则（
                【已有与【栈式于（处理连续语句于「符列」于句）】与尾】
            ）
        或有（语之方括号表达式于（语之连续表达式于「式们」））衔尾则（
                【已有与【（
                    若（为纯名称于式们）
                    则栈式于（
                        虑纯名称者（获取纯名称于式们）而
                        若（（串长度于「纯名称」）大于零）
                        则抽象语法之自由变量于纯名称
                        否则（抽象语法之式节点于（抽象语法之空缺）于【】）
                        ）
                    否则（栈式于
                （（读引用于（「函数合集」之解表达式引用））于「符列」于式们）
                ））】
                与尾】
            ）
        或有「其他2」则（发生事故于（『解表73：输入是』附（结构语法表示之「表示列」于输入）））
    ）也。


「：匹配可以作为一个操作符后续的操作符，
也就是获取的新操作符组件必须可以消除前面的输入
，不可以添加新的组件：」
「：我们目前假设不存在连续的参数组件，TODO：探究可否放松该要求：」
处理下个字符后续乃化「符列环境」而化栈素列而化分析树列而（栈素列合栈素列合分析树列）列也。
处理下个字符后续者循处理下个字符后续以会符列而会已有而会输入而
    （
        鉴输入而
            有【】则【】
            或有 （语之字符于始）衔尾则（
                    虑关键词们者「获取所有继续关键词」于一于「符列」中零中零而
                    虑可能解析者匹配操作符字符于「符列」于「已有」于输入于关键词们
                    而（
                        若「大于」于（长度于可能解析）于零
                        则可能解析
                        否则（【】）
                    ） 
            ）
            或有（语之分隔符）衔尾
                则（处理下个字符后续于「符列」于已有于尾）
            或有（语之圆括号表达式于（语之连续表达式于「其他语」））衔尾
                则（【】）
            或有（语之字符串常量于串）衔尾
                则（【】）
            或有（语之圆括号表达式于（语之连续语句于句））衔尾
                则（【】）
            或有（语之方括号表达式于（语之连续语句于句））衔尾
                则（【】）
            或有（语之方括号表达式于（语之连续表达式于「式们」））衔尾
                则（【】）
            或有「其他2」则（发生事故于（『解表73：输入是』附（结构语法表示之「表示列」于输入）））
        ）也。



「：输入头部
    如果是字符则查询对应的关键字，可能有多个匹配项，
        若无匹配，则查询最长的不认识的名字：」
分析输入乃化「符列环境」而化栈素列而化分析树列而化（化字符串而化栈素列而有）而
        （栈素列「：新的已有，倒序：」合栈素列「：正顺序：」合分析树列）列也。
        「：分析输入会返回新的已有栈，因为对于输入的分析可能会使得栈上的元素发生改变，
        我们要保证所有的返回的输入解析一定可以被规约，所以要在解析时排除不可规约的可能性：」
分析输入者会符列而会已有而会输入而会调试而
        
            「：查找下一个操作符在已有栈中的序数：」
            鉴（查找元素序数条件于（会素而鉴素而有（栈操作符于「先境」于「整符及序号们」）则阳或有「其他素」则阴）于「已有」）而
                有（可有「序数」）则（「：序数表示栈顶到第一个操作符所要跳过的表达式的个数：」
                    若序数大于零则
                    （
                        「：序数必须是一，因为我们假设不存在两个连续的参数。两个连续的参数将会使得很多的优化都不可以执行。：」
                        若序数大于一
                        则发生事故于『栈上不应当存在连续表达式！』
                        否则（
                                虑「
                                    获得可能操作符匹配结果乃化整数「：当前检查的字符串组件在已有栈中序数，
                                    根据单参数假设，序数必须指向一个字符串组件，
                                    组件的序数加二即是下个要匹配输入 （此处序数含义发生改变！有栈序数和组件序数）
                                    ：」而（栈素列合栈素列合分析树列）列也。
                                    获得可能操作符匹配结果者循获得可能操作符匹配结果以会序数而
                                        鉴（第N个于序数于「已有」）而
                                            有（栈操作符于「先境」于「当前符序们」）则
                                                （「：TODO 这边应当更新第N个，而不是复制：」
                                                    虑无者非常详细调试打印行于（会无而『[D][D]正在匹配操作符，序数：』附（整数表示于序数）附『，操作符：』附（栈素表示于（栈操作符于「先境」于「当前符序们」）））而
                                                    虑操作符后续解析者（「串联」于（态射于（会当前符序而
                                                        虑整符者二对子取零于当前符序而
                                                        虑序号者二对子取一于当前符序而
                                                        虑组件们者「获取所有组件」于「整符」而
                                                        「：取得输入组件的位置：」
                                                        若（序号加二）小于（长度于组件们）
                                                        「：下一个输入仍然是组件内部：」
                                                        则（虑下个组件者第N个于（序号加二）于组件们
                                                            而
                                                                若组件是字符串组件于（第N个于（序号加二）于组件们）
                                                                    则（（匹配操作符字符于「符列」于已有于输入于【「整符」与（序号加二）】）
                                                                      ）
                                                                    否则（「：下个字符是表达式，如果我们强制不可以出现连续的表达式参数，这个case是不可能的：」
                                                                        「： 处理下个字符开始于「符列」于输入 ：」
                                                                        发生事故于『组件中纯真连续的参数』
                                                                    ）
                                                            ）
                                                        否则（
                                                            若（序号加二）等于（长度于组件们）「：正好是这个组件的完结，我们去寻找上一个组件：」
                                                            则（
                                                                虑下个序数者（序数加（序号加一））
                                                                而若下个序数小于（长度于「已有」）「：栈中仍然存在上个组件：」
                                                                则（获得可能操作符匹配结果于下个序数）
                                                                否则（【】）「：栈中不存在上个组件：」
                                                            ）
                                                            否则（发生事故于『组件的长度不正确』）
                                                        ）
                                                    ）于当前符序们））而
                                                    「： 虑无者打印行于『操作符后续解析长度：』附（整数表示于（长度于（操作符后续解析）））而 ：」
                                                    操作符后续解析
                                                ）
                                            或有「其他栈操作符」则发生事故于『不可能285，期待栈操作符』也。


                                    （获得可能操作符匹配结果于序数）接（处理下个字符后续于「符列」于已有于输入）
                                」
                            ）
                        
                    ）
                    否则（
                        「：序数等于零， 后面可以是任意表达式：」
                        鉴「已有」而
                            「：我们需要特殊处理绑定式：」
                            有（栈操作符于「先境」于「整符及序号们」）衔尾则「：我们默认栈操作符不是结尾，结尾操作符必须归一，所以本操作符后必须跟一个表达式：」
                                （
                                    「：处理绑定后续，我们会每个绑定单独分出一个分支，此处没有优化：」
                                    （「串联」于（态射于（会整符及序号而
                                        虑整符者二对子取零于整符及序号而
                                        虑序号者二对子取一于整符及序号而
                                        鉴（「获取随后的绑定信息」于整符于序号）而
                                            有（可有「次字」）则（
                                                鉴（扫描绑定于输入于次字于（栈操作符于「先境」于【「整符」与（「序号」加二）】））
                                                    而有可有「绑素后」则【（（栈操作符于「先境」于【「整符」与（「序号」）】）衔尾）与（「绑素后」中零）与（「绑素后」中一）】
                                                    或有「可无」则【】）「：绑定必须解析成功，否则报错：」
                                            或有（可无）则（【】）
                                    ）于「整符及序号们」））
                                    接
                                    （
                                        「：处理非绑定后续：」
                                        虑非绑定符序们者滤于（会整符及序号而
                                            虑整符者二对子取零于整符及序号而
                                            虑序号者二对子取一于整符及序号而
                                                鉴（「获取随后的绑定信息」于整符于序号）而
                                                    有（可有「次字」）则（
                                                        阴
                                                    ）
                                                    或有（可无）则（
                                                        阳
                                                    ）
                                            ）于「整符及序号们」而
                                            处理下个字符开始于「符列」于（（栈操作符于「先境」于非绑定符序们）衔尾）于输入
                                    ）
                                ）
                            或有「其他已有」则（
                                处理下个字符开始于「符列」于已有于输入
                            ）
                    ）
                ）
                或有（可无）则（
                    若（长度于「已有」）大于零则
                    （
                        处理下个字符后续于「符列」于已有于输入「：栈上有表达式，可以处理后续的字符：」
                    ）
                    否则（
                        处理下个字符开始于「符列」于已有于输入「：我们刚开始，可以处理开始的字符：」
                    ））
        
        也。

「：给定组件的操作符标号，栈（缩减且，反转过的）和组件，其中栈和组件必须是相同长度，
    若匹配成功，返回元素或绑定组件的参数，
    若匹配失败，返回可无：」
匹配组件获取参数乃化整数而化栈素列而化组件列而或可有（表达式列）也。
匹配组件获取参数者（会符标号而会栈素们而会组件们而
    若（长度于栈素们）不等于（长度于组件们）
    则发生事故于『栈与组件长度必须相等』
    否则（
        虑匹配字符串操作符者
            （化（操作符合整数）列而化字符串而爻也
                （会符序们而会「组符名」而
                    存在吗于（会符序而
                            虑「栈整符」者二对子取零于符序而
                            虑「栈组序号」者二对子取一于符序而
                                （「串相等」于（获取操作符组件字符串于栈整符于栈组序号）于组符名）
                                                且（（获取标号于栈整符）等于符标号）
                    ）于符序们）
            ）
            而
        从左折叠于（
                会素组而会当前参数而
                鉴当前参数而
                有「可无」则「可无」
                或有（可有「当前参数内容」）则（
                    鉴（栈素合组件也素组）而
                        有（栈操作符于「先境」于「符序们」）与（字符串组件于「组符名」）则
                            （若（匹配字符串操作符于符序们于组符名）
                                则可有（「当前参数内容」）
                                否则「可无」 ）
                        或有（栈操作符于「先境」于「符序们」）与（特殊字符串组件于「组符名」于转）则
                            （若（匹配字符串操作符于符序们于组符名）
                                则可有（「当前参数内容」）
                                否则「可无」 ）
                        或有「其他」与（字符串组件于名）则「可无」
                        或有「其他」与（特殊字符串组件于名于转）则「可无」
                        或有素与（绑定组件）则
                            （
                                鉴素而
                                有栈绑定于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                「：要做：这两项我们应该支持，但目前可能会产生多种唯一解
                                或许我们应该比较解析是否生成了结构相同的抽象语法树，
                                    如果是的话则可不报错：」
                                或有其他则「可无」「：注：是否要propogate原因？：」
                            ）
                        或有素与（元素组件于「组优先」）则
                            （「：COPY Paste：」
                                鉴素而
                                有栈绑定于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                或有栈陌生字于串则（可有（当前参数内容接【抽象语法之自由变量于串】））
                                或有栈式于式则（可有（当前参数内容接【式】））
                                或有其他则「可无」「：注：是否要propogate原因？：」
                            ）
                        或有「其他」则（发生事故于『表192？』）
                ）
            ）于（可有【】）于（「拉链合并」于栈素们于组件们）
    ））也。

「：获取参数栈素列中首个字符串组件记住的环境，必须传入反转过的栈：」
获取规约前环境乃化栈素列而或可有「符列环境」也。
获取规约前环境者（会栈而
    虑可能先境们者滤态射于（会素而鉴素而有
        （栈操作符于「先境」于符序们）则（可有「先境」）
        或有「其他」则（可无））于栈而
    鉴「可能先境们」而
        有【】则（可无）
        或有（头衔尾）则（可有头））也。

进行一次栈尾规约乃化「符列环境」而化栈素列而（「符列环境」合（栈素列））列也。
进行一次栈尾规约者会境而会栈而
    虑（
        顶栈符序们者
            鉴栈而
                有（栈操作符于「顶先境」于「顶栈符序们」）衔「余下栈」则
                    「：如果栈顶不可能是prefix operator，：」
                    「顶栈符序们」
                或有（栈式于「顶式」）衔（栈操作符于「顶先境」于「顶栈符序们」）衔「余下栈」则
                    「顶栈符序们」
                或有「其他」则
                    （（操作符合整数）列也发生事故于『405无法进行栈尾规约』）也。

        「串联」于（打表态射于（顶栈符序们）于（
            会顶栈符序而
            虑「
                观抽象语法之书。
                顶栈整符者顶栈符序中零也。
                「符标号」者（获取标号于顶栈整符）也。
                组件们者获取所有组件于顶栈整符也。
                若「大于」于（长度于组件们）于（长度于栈）
                    则（【】）
                    否则（虑
                        （
                            栈素们者反转于（取于（长度于组件们）于栈）也。
                            余下栈素者放于（长度于组件们）于栈也。
                            参数乃或可有（表达式列）也。
                            参数者（匹配组件获取参数于符标号于栈素们于组件们）也。

                            先境者（鉴（获取规约前环境于栈素们）而
                                有（可无）则境
                                或有（可有「先境」）则先境）也。

                            结果乃（「符列环境」合栈素列）列也。
                            结果者（
                                鉴参数而
                                有「可无」则（
                                        非常详细调试打印行于（会无而『参数获取失败』）；
                                    【】）
                                或有「可有「参数列」」则（
                                        非常详细调试打印行于（会无而『参数获取成功』）；
                                    （虑可能阐述者（
                                                尝试运行于（会无而
                                                    获取阐述于顶栈整符于「参数列」
                                                ）于（会错误信息而
                                                    发生事故于（
                                                        错误信息
                                                            附『「：换行：」当前栈是：』附（「栈表示」于栈）
                                                            附『「：换行：」操作符是：』附（「操作符表示」于顶栈整符）
                                                            附『「：换行：」环境：』附（「符列环境表示」于境）
                                                    ）
                                                ）
                                            ）而
                                        鉴「可能阐述」而
                                            有（可有「阐述式」）则（（【先境与（（栈式于「阐述式」）衔余下栈素）】））
                                            或有「可无」则【】
                                    ）
                                ））也。

                            结果
                        ） 
                    ）。
            」
        ））
    ）也。
        
「：若规约成功，返回有，若规约失败，返回无：」
「：我们规约时会碰到一种情况
A 式 | B 且AB没有优先级关系，这种情况下就应该是 (A 式) B 还是 A (式 B)呢？
我们规约会选后者，首先检查 A的优先级没有比B高，
那么B会不会被移位是一个关键问题！如果我们发现B的优先级也没有A高，那么我们应该直接报错！
但是在这里，为了减少报错，
我们选择移位！之后在总体规约时就会变成A (式 B)。

本函数只进行可能规约并返回结果，不进行移位

我们要返回更新的栈操作符，因为规约与否取决于是什么样的栈操作符
：」
进行操作符规约乃化「符列环境」而化栈素列而化栈素而（「符列环境」合（栈素列）合栈素）列也。
进行操作符规约者循进行操作符规约以会境而会栈而会符而
    虑递归者进行操作符规约而
    虑无者非常详细调试打印行于（会无而『进行操作符规约中：』附（栈素表示于符）附『，栈顶：』附（若（长度于栈）大于三
                                                                则（「栈表示」于（取于三于栈））
                                                                否则（栈表示于栈）））而
    鉴符而
        有（栈操作符于「后后境」于「符序们」）则
            若（（长度于栈）小于二）
            则（【境与栈与符「：如果栈只有一个或没有元素，直接返回：」】）
            否则
            （
                鉴栈而
                    有（栈操作符于「顶先境」于「顶符序们」）衔「余下栈」则
                        「：如果栈顶不可能是postfix operator，因为移位时会规约：」
                        （【境与栈与符】）
                    或有（栈绑定于字）衔「余下栈」则
                        （【境与栈与符】）
                    或有（栈式于「顶式」）衔（栈操作符于「顶先境」于「顶栈符序们」）衔「余下栈」则
                    （
                        虑可以规约条件者（化（（操作符合整数）合（操作符合整数）合有）而爻也（会组合而
                                鉴（「组合」）而
                                    有（「整符」与「组件序号」）与（「顶栈整符」与「顶组件序号」）与（「元式」）则
                                        若（「组件序号」等于零）
                                            则（发生事故于『后续组件序号不应当等于零』）
                                            否则（
                                                若（（「顶组件序号」加二）不等于（长度于（获取所有组件于「顶栈整符」）））「：如果没到结尾，不规约：」
                                                    则（阴）
                                                    否则（
                                                        虑可以规约者
                                                            （（存在吗于（会甲而甲等于（获取标号于「顶栈整符」））于（
                                                                「：获得下个组件前的组件：」
                                                                鉴（第N个于（组件序号减一）于（获取所有组件于整符））
                                                                    而有元素组件于「同等优先级」则
                                                                        「获取所有同等或更高优先级的开放操作符」于（境中零）于（获取标号于整符）
                                                                    或有元素组件于「更高优先级」则「获取所有更高优先级的开放操作符」于（境中零）于（获取标号于整符）
                                                                    或有元素组件于「重置优先级」则（（获取集所有开放操作符于（境中零）））
                                                                    或有「其他」则发生事故于（『不可能的组件：299：』附（组件表示于「其他」））
                                                            ）））而
                                                        虑无者非常详细调试打印行于（会无而『检查可以规约：』附（爻表示于可以规约）附『，栈：』附（栈表示于符衔栈））而
                                                        可以规约
                                                ）
                                            ）
                            ））而
                        虑所有组合者「串联」于（打表态射于「符序们」于
                            （会后续符序而
                                （打表态射于顶栈符序们于（会顶栈符序而
                                    后续符序与顶栈符序与元
                                ））
                            ））而
                        虑可以规约与不可规约组合者
                            条件分类于「所有组合」于「可以规约条件」而
                            「：如果全部都可以规约，或者全部都不可以规约，可以采用快速处理：」
                        若（（长度于（「可以规约与不可规约组合」中零））等于零）
                            则
                            （
                                「：全部不可以规约，直接返回：」
                                【境与栈与符「：如果栈只有一个或没有元素，直接返回：」】
                            ）
                            否则
                            （
                                若（（长度于（「可以规约与不可规约组合」中一））等于零）
                                则（
                                    「：全部都可以规约，进行一次规约：」
                                    「串联」于（打表态射
                                                于（进行一次栈尾规约于「顶先境」于栈）
                                                于（会「后先境及后栈」而
                                                        （递归于（后先境及后栈中零）于（后先境及后栈中一）于符） 
                                    ））
                                ）
                                否则（
                                    「：不一致，全部打散：」
                                    「串联」于（打表态射于「所有组合」于（会组合而
                                        鉴（（操作符合整数）合（操作符合整数）合有也「组合」）而
                                            有（「整符」与「组件序号」）与（「顶栈整符」与「顶组件序号」）与（「元式」）则
                                                递归于境
                                                    于（（栈式于「顶式」）衔（栈操作符于「顶先境」于【「顶栈整符」与「顶组件序号」】）衔「余下栈」）
                                                    于（（栈操作符于「后后境」于【整符与组件序号】））
                                        ））

                                ）
                            ）
                    ）
                    或有「其他栈」则发生事故于『栈的格式有问题』
            ）
        或有「其他」则发生事故于『不存在』也。

移位或规约一步乃化「符列环境」而化栈素列而化栈素列而（「符列环境」合栈素列）列也。
移位或规约一步者循移位或规约一步以会境而会已有而会次字们而
    （「：我们更新了次字匹配，匹配的次字永远可以移位：」
        虑符列者「符列环境读取操作符集」于「境」而
        虑无者（详细调试打印行于（会无而『移位或规约一步：』附（栈表示于（反转于次字们））））而
        虑递归者「移位或规约一步」而
        鉴（已有与次字们）而
        有全栈与（【】）则（【（境与全栈）】）
        「：陌生字：」
        或有全栈与（（栈陌生字于字）衔「后次字们」）则递归于「境」于（（栈式于（自由变量于字））衔全栈）于后次字们
        「：绑定：」
        或有（栈）与（（栈绑定于甲）衔「后次字们」）则
            （递归于「境」「：绑定在操作符中更新：」于（（栈绑定于甲）衔（栈））于后次字们）
        「：表达式：」
        或有（栈）与（（栈式于式）衔「后次字们」）则
            （递归于「境」于（（栈式于式）衔（栈））于后次字们）
        「：普通操作符：」
        「：TODO进行规约后更新绑定信息？？？：」
        或有（栈）与（（栈操作符于「先先境」于「先符序们」）衔「后次字们」）则「：TODO 进行多次移位规约：」
            （「串联」于（
            打表态射于（进行操作符规约于境于栈于（栈操作符于「先先境」于「先符序们」））
                于（会「规约后境及规约后栈」而
                    鉴（规约后境及规约后栈）而
                        有「规约后境」与「规约后栈」与（栈操作符于「先境」于「符序们」）则
                        （ 
                            虑无者非常详细调试打印行于（会无而『进行操作符规约后栈之一：』附（栈表示于规约后栈））而
                            虑末尾符序们及非末尾符序们者
                                （条件分类于「符序们」于（会符序而
                                鉴符序而
                                    有「整符」与「组件序号」则
                                        （组件序号等于（（长度于（获取所有组件于（整符）））减一））））
                                而
                            「：分开处理末尾符序与非末尾符序：」
                            虑末尾符序们者末尾符序们及非末尾符序们中零而
                            虑非末尾符序们者末尾符序们及非末尾符序们中一而
                            「： 虑无者（打印行于『末尾符序：』附（整数表示于（长度于末尾符序们））附『，非末尾符序们：』附（整数表示于（长度于非末尾符序们）））而 ：」


                                （若（（长度于末尾符序们）大于零）
                                    则（
                                        「串联」于（打表态射于（进行一次栈尾规约于「规约后境」于（（栈操作符于「先境」于末尾符序们）衔规约后栈））
                                            于（会后先境及后栈而
                                                （递归于（后先境及后栈中零）于（后先境及后栈中一）于后次字们）
                                            ）
                                        ）
                                    ）
                                    否则【】）
                                接（
                                    若（（长度于非末尾符序们）等于零）
                                        则（【】）
                                        否则（
                                            虑剩余符序者（引用类于（操作符合整数）列也新引用于【】）而
                                            虑特殊结果者（「串联」于（打表态射于非末尾符序们于（会符序而
                                                    鉴符序而
                                                        有「整符」与「组件序号」则
                                                        （
                                                            鉴（获取组件于整符于组件序号）而
                                                                有（特殊字符串组件于名于转）则（
                                                                    虑后境及转后栈者转于（规约后境与规约后栈）而
                                                                    虑后境者后境及转后栈中零而
                                                                    虑转后栈者后境及转后栈中一而
                                                                    递归于「后境」于（栈操作符于规约后境于【整符与组件序号】）衔转后栈于后次字们）
                                                                或有「其他」则（
                                                                    写引用于剩余符序于（（读引用于剩余符序）接【符序】）；【】
                                                                ）
                                                        ）
                                                ）））而
                                                特殊结果接
                                                （
                                                    虑剩余者（读引用于剩余符序）而
                                                    「： 虑无者（打印行于『剩余长度：』附（整数表示于（长度于剩余）））而 ：」
                                                    若（（长度于剩余）大于零）
                                                        则（递归于「规约后境」于（栈操作符于规约后境于剩余）衔规约后栈于后次字们）
                                                        否则【】
                                                ）
                                                
                                                
                                            ）
                                ）
                        ）
                ）
            ））
        「：结束：」
        或有栈与（栈文件结尾衔【】）则
            （
                若（长度于栈）大于一
                则（
                    「串联」于（打表态射于（进行一次栈尾规约于境于栈）于（会
                        「后先境及后栈」而（递归于（后先境及后栈中零）于（后先境及后栈中一）于次字们）
                    ））
                ）否则
                【境与（栈文件结尾衔栈）】
            ）
        「：其他故障：」
        或有「其他」与输入则发生事故于（『豫言编译器/编译步骤/语法分析/表达式解析。豫:210 表达式解析遇到故障，在输入』
                    附（栈表示于（反转于输入））附『「：换行：」当前栈是：』附（栈表示于「其他」））
        或有「其他」则发生事故于『解表91』
    ）也。

「：一定会消耗输入：」
单一步骤乃化「符列环境」而化栈素列而化分析树列而化（化字符串而化栈素列而有）而（「符列环境」合栈素列合分析树列）列也。
单一步骤者会符列而会已有而会输入而会调试而
    鉴输入而
    有【】则发生事故于『输入不可为空105』
    或有「其他」则（
        虑「
            详细调试打印行于（会无而『正在执行单一步骤，输入是：』附（结构语法表示之「表示列」于输入）附『， 栈是』附（栈表示于「已有」））。
            「： 打印行于（『剩余输入长度：』附（整数表示于（长度于输入）））。 ：」
            输入解析者分析输入于「符列」于已有于输入于调试也。


            粗略调试打印行于（会无而『输入解析共』附（整数表示于（长度于输入解析））附『个，分别是：』附（以『，』合并（打表态射于输入解析于（会解析而栈表示于（解析中一）））））。
            若（长度于输入解析）等于零则（调试于『无输入解析：』于「已有」）否则元。

            结果者「串联」于（态射于（会甲而
                    鉴（（栈素列合栈素列合分析树列）也甲）而
                    有「更新已有」与「次字们」与「剩余输入」则
                                    （
                                        鉴（「移位或规约一步」于（「符列」）于更新已有于「次字们」）而
                                        有【】则（调试于『无规约：』于（（反转于次字们）接已有「：栈永远是反着的，打印时顺序会颠倒：」）
                                                    ；【】）
                                        或有「新已有列」则（
                                            打表态射于「新已有列」于（会新已有而
                                                （新已有中零）与（新已有中一）与剩余输入）
                                            ）
                                    ）
                    或有「其他2」则（发生事故于『匹配失误116』）
                ）
                于输入解析）也。

            结果
        」
    ）也。

「：返回可能的解：」
所有步骤乃化表达式列「：已完成的：」而
        化（「符列环境」合栈素列合分析树列）列「：待探索的：」而
        化（化字符串而化栈素列而有）「：调试：」而表达式列也。
所有步骤者循所有步骤以会已有结果而会待处理理解而会调试而
    鉴待处理理解而
        有【】则「已有结果」
        或有（（「符列」与「已有」与「输入」）衔「待处理尾」）则
        （
            鉴输入而
            有【】则
            （
                虑最终结果者
                （表达式列也
                    「串联」于（打表态射于（「移位或规约一步」于（「符列」）于已有于【栈文件结尾】）于
                        （会结果而
                            鉴结果而
                                有（「符」与「全栈」）则（
                                    鉴全栈而
                                        有栈文件结尾衔【】则【式节点于空缺于【】】
                                        或有栈文件结尾衔（栈式于式）衔【】则【式】
                                        或有栈文件结尾衔（栈陌生字于串）衔【】则【自由变量于串】
                                        或有「其他」则（调试于『全栈非单一表达式：』于「其他」；【】）「：解析失败：」
                                ）
                                「： 或有「可无」则（调试于『无尾规约』于「已有」；【】） ：」
                        ））
                ）而
                    「所有步骤」于（已有结果接最终结果）于待处理尾于调试
            ）
            或有（语之分隔符）衔「输入尾」
                则（「所有步骤」于已有结果于（（「符列」与已有与输入尾）衔待处理尾）于调试）
            或有「其他」则（
                虑（
                    粗略调试打印行于（会无而『表达式解析调试信息：当前已有表达式数：』附（整数表示于（长度于已有结果））附『，待处理理解个数：』附（整数表示于（长度于待处理理解））
                        附『，当前剩余输入长度：』附（整数表示于（长度于输入））
                        附『，当前输入头：』附（若（长度于输入）大于二
                                                则（结构语法表示之「表示列」于（取于二于输入））
                                                否则（结构语法表示之「表示列」于（输入）））
                        附『，当前栈头：』附（若（长度于已有）大于二
                                                则（「栈表示」于（取于二于已有））
                                                否则（「栈表示」于（已有））））。
                    下步者单一步骤于「符列」于已有于输入于调试也。
                    结果者（「所有步骤」于已有结果于（待处理尾接下步）于调试）也。
                    
                    结果
                ）
            ）
        ）也。
    
「：注：可能要加入背景操作符列：」
进行解析乃化「符列环境」而化分析树列「：输入：」而表达式也。
进行解析者会符列而会输入而
    虑（
        「： 打印行于（『表达式解析：进行解析：』附（结构语法表示之「表示列」于（输入）））。 ：」
        失败解析乃引用类于（栈素列列）也。
        失败解析者新引用于【】也。

        调试乃化字符串而化栈素列而有也。
        调试者会信息而会列而
            （虑无者（详细调试打印行于（会无而『分支解析失败，』附信息附『，栈：』附（栈表示于「列」）））而
            写引用于失败解析于（「列」衔（读引用于失败解析）
            ））也。


        结果乃表达式也。
        结果者尝试运行于（会不要而鉴（所有步骤于【】于（【「符列」与【】与输入】）于调试）而
                        有【】则
                            发生事故于（『无法解析，可能的理解：「：换行：」』附
                                    （以『，「：换行：」』合并（态射于栈表示于（读引用于失败解析））））
                            附『「：换行：」输入是：』附（结构语法表示之「表示列」于输入）
                            附『「：换行：」环境：』附（「符列环境表示」于「符列」）
                        或有「唯一解」衔【】则
                            （唯一解）
                        或有「多种解法」则
                            （
                                
                                （
                                    发生事故于『多于一个解法：「：换行：」』附
                                    （以『「：换行：」』合并（态射于（抽象语法表示之表达式表示）于（多种解法）））
                                    附『「：换行：」输入是：』附（结构语法表示之「表示列」于输入）
                                    附『「：换行：」环境：』附（「符列环境表示」于「符列」）
                                ）
            ））
            于（会错误信息而
                发生事故于（错误信息）
            ）
        也。

        结果
    ）也。

解表达式乃化「符列环境」而化分析树列而表达式也。
解表达式者会符列而会「树列」而
    （进行解析于「符列」于「树列」）
也。

写引用于「函数合集」之解表达式引用于解表达式。