
寻观标准库之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树相等方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之模块操作之书。
寻观豫言编译器之编译数据之编译配置之编译期输出之书。

寻观豫言编译器之编译数据之抽象绑定树结构之命名环境术之书。

观抽象语法之书。
观抽象语法表示之书。

寻观豫言编译器之编译数据之操作符之操作符数据结构之书。
寻观豫言编译器之编译步骤之语法分析之函数合集之书。
寻观豫言编译器之编译步骤之类型检查之元变量管理之书。
寻观豫言编译器之编译步骤之类型检查之顶部归一化之书。
寻观拓展库之顺序标识符之顺序标识符之书。

寻观豫言编译器之编译数据之编译配置之编译期输出之书。
寻观豫言编译器之编译数据之文件管理之编译文件信息之书。
寻观豫言编译器之编译数据之抽象绑定树结构之静态单例类型处理之书。
寻观豫言编译器之编译步骤之总体过程之编译过程工具之书。

「： 寻观代码生成工具之书。 ：」
寻观直接代码生成之书。
寻观豫言编译器之编译数据之编译配置之全局配置之书。
寻观豫言编译器之编译步骤之代码生成之工具之工具之书。
「： 寻观续延转换代码生成工具之书。 ：」


尾调用返回乃化字符串而字符串也。
尾调用返回者会名而
        『ret i64* %"』附名附『"』也。

「：给定字符串，条件输出可以直接插入源码的字符串：」
调试写乃化（化有而字符串）而字符串也。
调试写者会串而若（读引用于（字节码打印调试信息））
       则 『// /* 』附（串查找替换于（串于元）于『「：换行：」』于『「：「：：」换行：」』）附『 */「：换行：」』否则『』也。



「：需要跳过不合法的标识符：」
标识符转义乃化字符串而字符串也。
标识符转义者会串而
    「串组合并」于（打表态射于（获取字符于串）于（会字符而
         鉴字符而
            有 『-』则『_』
            或有「其他字符」则「其他字符」
    ））
    也。

代码生成乃化（化字符串而有）「：写全局文件：」
         而化字符串列「：当前所有的自由变量：」
         而化表达式「：待变换的式子：」
         而字符串「：生成的代码：」也。
代码生成者循「代码生成」以会写出而会已有自由变量而会式而
    虑「

        递归同变量者代码生成于写出于已有自由变量也。
        递归者代码生成于写出也。
        保留字段者下个字符序数于『_保留_』也。

        解绑乃承甲而化表达式而化（化字符串而化表达式而甲）而甲也。
        解绑者会式而会继续而
            虑名及后式者（解构抽象不重复名称于（更新可能绑定名于式）于已有自由变量）「：强制更新名称：」
            而继续于（名及后式中零）于（名及后式中一）也。


        「读名」者「读取直接变量」也。


        详细调试打印行于（会无而『代码生成中：』附（表达式表示于式））。

        转换结果乃字符串也。
        转换结果者
        尝试运行于（
            会无而
            鉴式而
                有（式节点于「内联虑」于「当前」衔「下个」衔【】）则
                    （解绑于下个于（会后名而会后下个而
                        （鉴当前而
                                    有（式节点于（拉姆达抽象于「拉形」）于「单绑定」衔【】）则
                                    （
                                        虑函数内容者（
                                                解绑于单绑定于（会参数名而会函体而
                                                    （
                                                        （包裹函数体于【 参数名】于（
                                                            「递归」于【 参数名】于函体
                                                        ））
                                                    ）
                                        ））而
                                        「： （调试写于（会无而（表达式表示于当前）））附 ：」
                                        『let 』附后名附『 = 』附（函数内容）附『「：换行：」』附
                                        （递归于（已有自由变量接【后名】）于后下个）
                                    ）
                                    或有（式节点于（函数调用于「函形」）于「函数」衔「参数一」衔【】）则
                                        （
                                            虑函数名者读名于函数而
                                            虑参数一名者读名于参数一而
                                            （调试写于（会无而（表达式表示于当前）））附
                                            「： 『%"函数指针』附保留字段附『" = bitcast i64* %"』附函数名附『" to i64* (i64*, i64*, i64*)*换行』附 ：」
                                            （『let 』附后名附『 = 』附函数名附（获取普通参数签名于【参数一名】）附『「：换行：」』）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ）
                                    「： 或有（式节点于（拉姆达抽象两参数）于「双绑定」衔【】）则
                                    （
                                        虑函数内容者（
                                                解绑于双绑定于（会参数名而会单绑定而
                                                    解绑于单绑定于（会续延函数名而会函体而
                                                        （
                                                            （包裹函数体于【 参数名，续延函数名】于（
                                                                「递归」于【 参数名，续延函数名】于函体
                                                            ））
                                                        ）
                                                ）
                                        ））而
                                        「： （调试写于（会无而（表达式表示于当前）））附 ：」
                                        『let 』附后名附『 = 』附（函数内容）附『「：换行：」』附
                                        （递归于（已有自由变量接【后名】）于后下个）
                                    ）
                                    或有（式节点于（函数调用两参数）于「函数」衔「参数一」衔「参数二」衔【】）则
                                        （
                                            虑函数名者读名于函数而
                                            虑参数一名者读名于参数一而
                                            虑参数二名者读名于参数二而
                                            （调试写于（会无而（表达式表示于当前）））附
                                            「： 『%"函数指针』附保留字段附『" = bitcast i64* %"』附函数名附『" to i64* (i64*, i64*, i64*)*换行』附 ：」
                                            （『let 』附后名附『 = 』附函数名附（获取普通参数签名于【参数一名，参数二名】）附『「：换行：」』）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ） ：」
                                    「： 或有（式节点于（拉姆达抽象三参数）于「三绑定」衔【】）则
                                    （
                                        虑函数名者下个字符序数于（后名附『_函数』）而
                                        虑无者（
                                            解绑于三绑定于（会闭包名而会双绑定而
                                                解绑于双绑定于（会参数名而会单绑定而
                                                    解绑于单绑定于（会续延函数名而会函体而
                                                        （写出于
                                                            （包裹函数体于函数名于【闭包名， 参数名，续延函数名】于（
                                                                「递归」于【闭包名， 参数名，续延函数名】于函体
                                                            ））
                                                        ）
                                                ）
                                            ）
                                        ））而
                                        「： （调试写于（会无而（表达式表示于当前）））附 ：」
                                        『%"』附后名附『" = bitcast i64* (i64*, i64*, i64*)* @"』附（函数名）附『" to i64*「：换行：」』附
                                        （递归于（已有自由变量接【后名】）于后下个）
                                    ）
                                    或有（式节点于（函数调用三参数）于「函数」衔「参数一」衔「参数二」衔「参数三」衔【】）则
                                        （
                                            虑函数名者读名于函数而
                                            虑参数一名者读名于参数一而
                                            虑参数二名者读名于参数二而
                                            虑参数三名者读名于参数三而
                                            （调试写于（会无而（表达式表示于当前）））附
                                            『%"函数指针』附保留字段附『" = bitcast i64* %"』附函数名附『" to i64* (i64*, i64*, i64*)*「：换行：」』附
                                            （『%"』附后名附『" = musttail call 』附默认调用规范附『 i64* %"函数指针』附（保留字段）附『"』附（获取普通参数签名于【参数一名，参数二名，参数三名】）附『「：换行：」』）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ） ：」
                                    或有（式节点于（拉姆达抽象续延）于「单绑定」衔【】）则
                                        （
                                           虑函数内容者（
                                                    解绑于单绑定于（会参数名而会函体而
                                                        （
                                                            （包裹函数体于【 参数名】于（
                                                                「递归」于【 参数名】于函体
                                                            ））
                                                        ）
                                            ））而
                                            「： （调试写于（会无而（表达式表示于当前）））附 ：」
                                            『let 』附后名附『 = 』附（函数内容）附『「：换行：」』附
                                            （递归于（已有自由变量接【后名】）于后下个） 
                                        ）
                                    或有（式节点于（函数调用续延）于「函数」衔「参数」衔【】）则
                                        （
                                            虑函数名者读名于函数而
                                            虑参数名者读名于参数而
                                            （调试写于（会无而（表达式表示于当前）））附
                                            「： 『%"函数指针』附保留字段附『" = bitcast i64* %"』附函数名附『" to i64* (i64*, i64*, i64*)*换行』附 ：」
                                            （『let 』附后名附『 = 』附函数名附（获取普通参数签名于【参数名】）附『「：换行：」』）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                                「： （调试写于（会无而（表达式表示于当前）））附
                                                『br label %"』附函数名附『_参数标签_』附（整数表示于当前序数）附『"「：换行：」』附
                                                『"』附函数名附『_参数标签_』附（整数表示于当前序数）附『":「：换行：」』附
                                                『%"』附函数名附『_参数_』附（整数表示于当前序数）附『" = bitcast i64* %"』附参数名附『" to i64*「：换行：」』附
                                                『br label %"』附函数名附『_进入标签"』附『「：换行：」』 ：」
                                        ）
                                    或有「其他」则
                                        （
                                            （调试写于（会无而（表达式表示于当前）））附
                                            （「直接代码生成」于写出于后名于当前）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ））
                    ））
                或有（式节点于「递归内联虑无类型」于「当前」衔「下个」衔【】）则
                （
                   （解绑于下个于（会后名而会后下个而 
                        虑递归函数名者下个字符序数于后名附『_递归函数名_』而
                        解绑于「当前」于（会参数名而会参数体而
                            『let 』附（递归函数名）附『 = 』附
                                （包裹函数体于【 参数名】于（
                                    「递归」于【 参数名】于参数体
                                ））附『;「：换行：」』附
                            『let 』附（后名）附『 = 』附（递归函数名）附『(』附递归函数名附『);「：换行：」』附
                            （递归于（已有自由变量接【后名】）于后下个）
                        ）
                   ））
                ）
                
                或有（式节点于（爻分支节点）于「爻式」衔「阳式」衔「阴式」衔【】）则
                    （
                        虑爻式名者读名于爻式而
                        『if (』附（爻式名）附『) {「：换行：」』附
                        （递归同变量于阳式）附『「：换行：」』附
                        『} else {「：换行：」』附
                        （递归同变量于阴式）附
                        『}「：换行：」』
                    ）

                或有（式节点于模式匹配于「分析式」衔「分支们」）则
                    （
                        「：分支会被编译成当前自由变量加上被匹配的变量，分支自己加入更多的变量：」
                        虑分析名者读名于分析式而
                            （虑「
                                处理后分支们及默认分支者模式匹配分支分析于「分支们」也。

                                处理后分支们者处理后分支们及默认分支中零也。
                                默认分支者处理后分支们及默认分支中一也。
                                
                                默认分支代码者（字符串也鉴默认分支而
                                    有（式节点于（变量模式匹配分支）于「结果」衔【】）则
                                        （
                                            （递归同变量于（式替换于（自由变量于分析名）于结果））
                                        ）
                                    或有「其他」则（
                                        发生事故于『默认分支格式错误』附（表达式表示于默认分支）
                                    ））也。


                                处理分支乃化表达式列而字符串也。
                                处理分支者循处理分支以会剩余分支们而
                                    鉴剩余分支们而
                                        有【】则（
                                            『 {「：换行：」』附
                                            默认分支代码
                                            附『}「：换行：」』
                                        ）
                                        或有「当前」衔「剩余」则（
                                            （鉴当前而
                                                有（式节点于（常量模式匹配分支）于（式节点于（字符串节点于「串」）于【】）衔「结果」衔【】）则
                                                    （
                                                        『if (』附分析名附『 === 』附（癸象表示字符串于串）附『) {「：换行：」』附
                                                            （递归同变量于结果）附
                                                        『} else 「：换行：」』附
                                                        （处理分支于剩余）
                                                        
                                                    ）
                                                或有（式节点于（常量模式匹配分支）于（式节点于（整数节点于「数」）于【】）衔「结果」衔【】）则
                                                    （
                                                        『if (』附分析名附『 === 』附（整数表示于数）附『) {「：换行：」』附
                                                            （递归同变量于结果）附
                                                        『} else 「：换行：」』附
                                                        （处理分支于剩余）
                                                        
                                                    ）
                                                或有（式节点于（唯一构造器模式匹配分支于「序数」）于「结果」衔【】）则
                                                            （解绑于结果于（会绑定名而会后续而
                                                        『if (』附分析名附『[0] === 』附（整数表示于序数）附『) {「：换行：」』附
                                                                （绑定名）附『 = 』附分析名附『[1];「：换行：」』附
                                                                （递归于（已有自由变量接【绑定名】）于后续）附
                                                        『} else 「：换行：」』附
                                                        （处理分支于剩余）
                                                            ））
                                                或有「其他」则（发生事故于『生218：模式匹配分支，却得到了』附（表达式表示于当前））
                                            ）
                                        ）也。

                                字符串也
                                鉴处理后分支们而
                                    有【】则
                                        （
                                            默认分支代码
                                        ）
                                    或有「其他」则（
                                        （处理分支于处理后分支们）附『「：换行：」』
                                    ）
                            」）
                    ）
                或有（式节点于（续延调用节点）于「续参」衔【】）则（
                    「： 发生事故于『未有244』 ：」
                    解绑于续参于（会续延名而会续参体而
                        虑续延名者下个字符序数于『续延』而
                        『let 』附续延名附『 = (value) => {「：换行：」』附
                        『    throw yyContinuationException(value, 』附（癸象表示字符串于续延名）附『);「：换行：」』附
                        『};「：换行：」』附
                        『try {「：换行：」』附
                        （递归于（已有自由变量接【续延名】）于续参体）附
                        『} catch (e) {「：换行：」』附
                        『    if (e instanceof yyContinuationException && e.id === 』附（癸象表示字符串于续延名）附『) {「：换行：」』附
                        『        return e.value;「：换行：」』附
                        『    } else {「：换行：」』附
                        『        throw e;「：换行：」』附
                        『    }「：换行：」』附
                        『}「：换行：」』
                    ）
                ）
                或有「其他」则
                    （
                        虑返回名者下个字符序数于『结果』而
                        （「直接代码生成」于写出于返回名于「其他」）
                        「： 附（续延返回于『』附返回名附『』） ：」
                        附（『return 』附返回名附『「：换行：」』）
                    ）
        ） 
            于（会异常而
                发生事故于异常附『「：换行：」在代码生成』附（表达式表示于式）附『时』
        ） 
        也。

        转换结果
」
也。
「： 写引用于代码生成引用于代码生成。 ：」
癸本单个文件代码生成顶层乃化字符串列而「：先前编译的全局模块名：」
             化字符串而「：当前文件路径：」
             化字符串而「：全局名，需要声明存储：」
             化字符串而「：全局函数名：」
             化表达式而「：待变换式：」
             字符串「：编译模块的源码：」也。
癸本单个文件代码生成顶层者会先前模块路径名而会当前路径而会全局名而会全局函数名而会式而
    虑输出引用者新引用于【】而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑无者（写出于
        『let 』附（标识符转义于全局函数名）附『 = () => {「：换行：」』附
        （「代码生成」于写出于【】于式）附
        『}』
        ）而
    虑最终输出源码者（以『「：换行：」』合并（读引用于输出引用））而
    最终输出源码
    也。 

「：上个是单独文件编译，我们未来版本可能会用到，不过因为性能考虑，我们优先使用整体编译：」
癸本可执行文件代码生成顶层乃
             化表达式而字符串「：编译模块的源码：」也。
癸本可执行文件代码生成顶层者会式而
    虑输出引用者新引用于【】而
    虑模块标准名者下个字符序数于『总体模块』而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑本次函数名者下个字符序数于『整体函数』而
    虑无者（写出于
        『let 』附本次函数名附『"(){「：换行：」』附
        （「代码生成」于写出于【】于式）附
        『}』
        ）而
    「：写全局的模块：」
    虑无者（写出于
        『let entryMain = () => {「：换行：」』附
        『』附本次函数名附『()「：换行：」』附 「：这里不must musttail 因为这是入口函数：」
        『};「：换行：」』附
        『entryMain();』
        ）而
    虑最终输出源码者『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    最终输出源码
    也。