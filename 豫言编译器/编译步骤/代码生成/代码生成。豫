「：This is untyped closure conversion. 
I have prepared groundwork for typed closure conversion, but I 
have not yet studied it.
：」



寻观标准库之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树相等方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之模块操作之书。
寻观豫言编译器之编译数据之编译配置之编译期输出之书。

寻观豫言编译器之编译数据之抽象绑定树结构之命名环境术之书。

观抽象语法之书。
观抽象语法表示之书。
观抽象语法相等之书。

寻观豫言编译器之编译数据之操作符之操作符数据结构之书。
寻观豫言编译器之编译步骤之语法分析之函数合集之书。
寻观豫言编译器之编译步骤之类型检查之元变量管理之书。
寻观豫言编译器之编译步骤之类型检查之顶部归一化之书。
寻观拓展库之顺序标识符之顺序标识符之书。

寻观豫言编译器之编译数据之编译配置之编译期输出之书。
寻观豫言编译器之编译数据之文件管理之编译文件信息之书。
寻观豫言编译器之编译数据之抽象绑定树结构之静态单例类型处理之书。

寻观代码生成工具之书。
寻观直接代码生成之书。

空返回乃字符串也。
空返回者『%"零值" = inttoptr i64 0 to i64*「：换行：」』附
        『ret i64* %"零值"』也。

续延函数名者『豫言保留续延函数』也。



代码生成乃化（化字符串而有）「：写全局文件：」
         而化字符串列「：当前所有的自由变量：」
         而化表达式「：待变换的式子：」
         而字符串「：函数名，必须以自由变量调用：」也。
代码生成者循「代码生成」以会写出而会已有自由变量而会式而
    虑「

        递归同变量者代码生成于写出于已有自由变量也。
        递归者代码生成于写出也。


        返回名者下个字符序数于『生成函数』也。




        已有声明参数签名者获取声明参数签名于（已有自由变量）也。

        「读名」者读取自由变量也。


        包裹函数体乃化字符串而字符串也。
        包裹函数体者会串而『define internal i64* @"』附返回名附『"』附已有声明参数签名附『 {「：换行：」』附（串）附『「：换行：」}』也。

        生成续延包并调用乃
              化字符串而「：本函数体一开始内容：」
              化（或可有字符串）而「：递归续延需要写入的全局变量名，非递归请传可无：」
              化表达式「：待变换的式子：」
              而化字符串「：最终调用的函数，会传入生成的续延：」
              而化字符串列「：最终调用的函数的参数，不包括传入的续延，会传入生成的续延：」
              而有也。
        生成续延包并调用者会开始内容而会可能全局名而会下个而会递归函数名而会参数名们而
            解绑于下个于（会后名而会后下个而
                            虑数组创建函数二者创建固定长度的数组于写出于（二）而
                            虑下个函数者递归于（已有自由变量接【后名】）于后下个而
                            虑续延开始内容者（
                                鉴「可能全局名」而有「可无」则『』
                                或有（可有全局名）则「：续延：第一个参数是闭包，第二个参数是返回值。递归：第一个参数是闭包，第二个参数是Kont：」
                                    （虑数组创建函数者创建固定长度的数组于写出于（（长度于已有自由变量））而
                                        『%"递归变量包" = call i64* @"』附（数组创建函数）附『"』附（获取普通参数签名于已有自由变量）附『「：换行：」』附
                                        『%"递归函数包" = call i64* @"』附（数组创建函数二）附『"』附（获取普通参数签名于【后名，『递归变量包』】）附『「：换行：」』附
                                        『store i64* %"递归函数包", i64** @"』附（全局名）附『"「：换行：」』
                                    ）
                            ）而
                            虑递归续延名者下个字符序数于『递归续延名』而
                            虑无者（写出于（「：续延闭包中所有的自由变量以及原先续延：」
                                    『define internal i64* @"』附递归续延名附『"(i64* %"续延函数闭包", i64* %"』附后名附『") {「：换行：」』附
                                    『i64* "续延函数闭包指针" = bitcast i64* %"续延函数闭包" to i64** 「：换行：」』附
                                    （「串组合并」于（态射序号于（会序号而会变名而
                                        『%"』附变名附『指针" = getelementptr i64*, i64** %"续延函数闭包指针", i64 』附（整数表示于序号）附『「：换行：」』附
                                        『%"』附变名附『" = load i64*, i64** %"』附变名附『指针"「：换行：」』
                                        ）于已有自由变量））附
                                    续延开始内容附
                                    『%"原先续延指针" = getelementptr i64*, i64** %"续延函数闭包指针", i64 』附（整数表示于（长度于已有自由变量））附『「：换行：」』附
                                    『%"』附续延函数名附『" = load i64*, i64** %"原先续延指针"「：换行：」』附
                                    『%"最终结果" = call i64* @"』附（下个函数）附『"』附（获取声明参数签名于（已有自由变量接【后名】））附『「：换行：」』附
                                    （空返回）
                                ））而
                            虑数组创建函数者创建固定长度的数组于写出于（（长度于已有自由变量）加一）而
                            （写出于
                                （包裹函数体于（
                                    开始内容附
                                    『%"递归续延包" = call i64* @"』附（数组创建函数）附『"』附已有声明参数签名附『「：换行：」』附
                                    『%"递归续延函数指针" = bitcast i64* (i64*, i64*)* @"』附（递归续延名）附『" to i64* 「：换行：」』附
                                    『%"递归续延" = call i64* @"』附（数组创建函数二）附『"』附（获取普通参数签名于【『递归续延函数指针』，『递归续延包』】）附『「：换行：」』附
                                    『%"』附（『返回』）附『" = call i64* 』附（递归函数名）附『』附（获取普通参数签名于（参数名们接【『递归续延』】））附『「：换行：」』附
                                    （空返回）
                                ））
                        ）
                    ）也。


        续延返回乃化字符串而字符串也。
        续延返回者会串而
                『%"函数包指针" = bitcast i64** @"』附（续延函数名）附『" to i64**「：换行：」』附
                『%"函数值指针" = getelementptr i64*, i64** %"函数包指针", i64 0「：换行：」』附
                『%"函数值值" = load i64*, i64** %"函数值指针"「：换行：」』附
                『%"函数值" = bitcast i64* %"函数值值" to i64* (i64*, i64*)*「：换行：」』附
                『%"闭包值指针" = getelementptr i64*, i64** %"函数包指针", i64 1「：换行：」』附
                『%"闭包值" = load i64*, i64** %"闭包值指针"「：换行：」』附
                『%"默认返回值" = call %"函数值"(i64* %"闭包值", i64% %"』附串附『"』附
            「： （「直接代码生成」于写出于『默认返回值』于（式节点于（闭包函数调用节点）于【自由变量于（续延函数名），自由变量于串】））附 ：」
            （空返回）
            也。


        详细调试打印行于（会无而『代码生成中：』附（表达式表示于式））。

        转换结果乃有也。
        转换结果者
        尝试运行于（
            会无而
            鉴式而
                有（式节点于「内联虑」于当前衔下个衔【】）则
                    （解绑于下个于（会后名而会后下个而
                        （鉴当前而
                                    有（式节点于（闭包拉姆达抽象）于双绑定衔闭包衔【】）则
                                        （
                                            「： 虑函数名者下个字符序数于『函数』而 ：」
                                            虑函数名者（解绑于双绑定于（会闭包名而会单绑定而
                                                解绑于单绑定于（会参数名而会函体而
                                                    虑函体函数名者「递归」于【闭包名， 参数名】于函体而
                                                    函体函数名
                                                ）
                                            ））而
                                            虑闭包名者读名于闭包而
                                            虑创建数组名者创建固定长度的数组于写出于二而「：优化！：」
                                            虑下个函数者递归于（已有自由变量接【后名】）于后下个而
                                            （（写出于
                                                （包裹函数体于（
                                                『%"函数值" = bitcast i64* (i64*, i64*, i64* (i64*)*)* @"』附（函数名）附『" to i64*「：换行：」』附
                                                （『%"』附（后名）附『" = call i64* @"』附（创建数组名）附『"』附（获取普通参数签名于【『函数值』，闭包名】））附
                                                『%"后续" = call i64* @"』附（下个函数）附『"』附（获取声明参数签名于（已有自由变量接【后名】））附『「：换行：」』附
                                                （空返回）
                                                ）））
                                            ）
                                        ）
                                        或有（式节点于（闭包函数调用节点）于函数衔参数衔【】）则
                                        （
                                            虑函数名者读名于函数而
                                            虑参数名者读名于参数而
                                            生成续延包并调用于（
                                                    『%"函数包指针" = bitcast i64* %"』附（函数名）附『" to i64**「：换行：」』附
                                                    『%"函数值指针" = getelementptr i64*, i64** %"函数包指针", i64 0「：换行：」』附
                                                    『%"函数值值" = load i64*, i64** %"函数值指针"「：换行：」』附
                                                    『%"函数值" = bitcast i64* %"函数值值" to i64* (i64*, i64*, i64*)*「：换行：」』附
                                                    『%"闭包值指针" = getelementptr i64*, i64** %"函数包指针", i64 1「：换行：」』附
                                                    『%"闭包值" = load i64*, i64** %"闭包值指针"「：换行：」』
                                            ）于「可无」于下个于『%"函数值"』于【『闭包值』，参数名】
                                        ）
                                        或有（式节点于递归变量节点于自变名衔【】）则
                                        （
                                            虑递归全局名者读名于自变名而
                                            生成续延包并调用于（
                                                    『%"函数包指针" = bitcast i64** @"』附（递归全局名）附『" to i64**「：换行：」』附
                                                    『%"函数值指针" = getelementptr i64*, i64** %"函数包指针", i64 0「：换行：」』附
                                                    『%"函数值值" = load i64*, i64** %"函数值指针"「：换行：」』附
                                                    『%"函数值" = bitcast i64* %"函数值值" to i64* (i64*, i64*)*「：换行：」』附
                                                    『%"闭包值指针" = getelementptr i64*, i64** %"函数包指针", i64 1「：换行：」』附
                                                    『%"闭包值" = load i64*, i64** %"闭包值指针"「：换行：」』
                                            ）于「可无」于下个于『%"函数值"』于【『闭包值』】
                                        ）
                                    或有「其他」则
                                        （
                                            虑下个函数者递归于（已有自由变量接【后名】）于后下个而
                                            
                                            （写出于
                                                （包裹函数体于（
                                                    （「直接代码生成」于写出于后名于当前）附
                                                    『%"后续" = call i64* @"』附（下个函数）附『"』附（获取声明参数签名于（已有自由变量接【后名】））附『「：换行：」』附
                                                    （空返回）
                                                ）））
                                        ））
                    ））
                
                或有（式节点于（爻分支节点）于爻式衔阳式衔阴式衔【】）则
                    （
                        虑爻式名者读名于爻式而
                        虑阳式函者递归同变量于阳式而
                        虑阴式函者递归同变量于阴式而
                        写出于（
                            包裹函数体于（
                                『%"爻" = ptrtoint i64* %"』附（爻式名）附『" to i1「：换行：」』附
                                『%"爻为真" = icmp ne i1 %"爻", 0「：换行：」』附
                                『br i1 %"爻为真", label %"真", label %"假"「：换行：」』附
                                『"真":「：换行：」』附
                                『%"真值" = call i64* @"』附（阳式函）附『"』附（已有声明参数签名）附『「：换行：」』附
                                『br label %"后"「：换行：」』附
                                『"假":「：换行：」』附
                                『%"假值" = call i64* @"』附（阴式函）附『"』附（已有声明参数签名）附『「：换行：」』附
                                『br label %"后"「：换行：」』附
                                『"后":「：换行：」』附「：其实这里不会执行，上述两个均不会返回：」
                                『%"结果值" = phi i64* [ %"真值", %"真" ], [ %"假值", %"假" ]「：换行：」』附
                                （空返回）
                            ）
                        ）
                    ）

                或有（式节点于「闭包递归内联虑无类型」于双绑定衔闭包衔下个衔【】）则
                （
                    （
                        虑递归函数引用名者下个字符序数于『递归函数引用』而
                        虑递归函数名者下个字符序数于『递归函数』而
                        虑无者（写出于『@"』附递归函数引用名附『" = internal i64* @"未赋值递归函数"』）而
                        虑无者（解绑于双绑定于（会闭包名而会单绑定而
                            虑函体者式替换于（自由变量于递归函数名）于单绑定而
                            虑函体函数名者递归于【闭包名】于函体而
                                写出于（
                                    『define internal i64* @"』附（递归函数名）附『"』附（获取声明参数签名于【闭包名】）附『 {「：换行：」』附
                                    『%"返回值" = call i64* @"』附（函体函数名）附『"』附（获取声明参数签名于【闭包名】）附『「：换行：」』附
                                    空返回附『「：换行：」』附
                                    『}』
                                ）
                            ）
                        ）而
                        虑闭包名者读名于闭包而
                        生成续延包并调用于『』于（可有递归函数引用名）于下个于『@"』附递归函数名附『"』于【闭包名】
                        ）
                ）
                或有（式节点于模式匹配于分析式衔分支们）则
                    （
                        「：分支会被编译成当前自由变量加上被匹配的变量，分支自己加入更多的变量：」
                        虑分析名者读名于分析式而
                        「： 虑新参数者获取参数签名于（已有自由变量接【『分析式』】）而 ：」
                        写出于（    
                            包裹函数体于（
                                （虑「
                                    处理分支乃化整数而化表达式列而字符串也。
                                    处理分支者循处理分支以会数而会剩余分支们而
                                        鉴剩余分支们而
                                            有【】则（
                                                『分支』附（整数表示于数）附『:「：换行：」』附
                                                『%"返回" = call i64* yyThrowException(i64* 0)「：换行：」』附
                                                （空返回）
                                            ）
                                            或有（当前）衔剩余则（
                                                虑条件函数者编译模式匹配分支条件于写出于（获取模式匹配分支模式于当前）而
                                                虑执行函数者递归于（已有自由变量接【分析名】）于当前而
                                                『"分支』附（整数表示于数）附『":「：换行：」』附
                                                『%"条件" = call i1 @"』附（条件函数）附『"(i64* %"分析式")「：换行：」』附
                                                『br i1 %"条件", label %"进入", label %"分支"』附（整数表示于（数加一））附『「：换行：」』附
                                                『进入:「：换行：」』附
                                                『%"返回" = call i64* @"』附（执行函数）附『"』附（获取声明参数签名于（已有自由变量接【『分析式』】））附『「：换行：」』附
                                                空返回附『「：换行：」』附
                                                （处理分支于（数加一） 于剩余）
                                            ）也。
                                    处理分支于零于分支们
                                」）
                            ）
                        ）
                    ）
                或有（式节点于（模式匹配分支）于模式衔结果衔【】）则
                    （
                        「： 虑无者打印行于『218』而 ：」
                        虑新变量们者读取模式匹配新变量于模式而
                        「： 虑无者打印行于『210』而 ：」
                        虑结果函数者递归于（已有自由变量接新变量们）于结果而
                        「： 虑无者打印行于『410』而 ：」
                        虑分析式名者『分析式』而
                        「： 虑无者打印行于『510』而 ：」
                        写出于（
                            『def i64* @"』附（返回名）附『"』附（获取声明参数签名于（已有自由变量接【分析式名】））附『 {「：换行：」』附
                            （编译模式匹配变量于写出于分析式名于模式）附
                            『%"返回值" = call i64* @"』附（结果函数）附『"』附（获取声明参数签名于（已有自由变量接新变量们））附『「：换行：」』附
                            空返回附『「：换行：」』附
                            『}』
                        ）
                    ）
                或有（式节点于（续延调用节点）于续参衔【】）则（
                    解绑于续参于（会续延名而会续参体而
                        虑续参体函者递归于（已有自由变量接【续延名】）于续参体而
                        写出于（
                            包裹函数体于（
                                『%"』附（续延名）附『" = bitcast i64* %"』附续延函数名附『" to i64*「：换行：」』附
                                『%"返回" = call i64* @"』附（续参体函）附『"』附（获取声明参数签名于（已有自由变量接【续延名】））附『「：换行：」』附
                                （空返回）
                            ）
                        ）
                    ）
                ）
                或有「其他」则
                    （
                        写出于（
                            包裹函数体于（
                                虑返回名者下个字符序数于『结果』而
                                （「直接代码生成」于写出于返回名于「其他」）
                                附（续延返回于『% "』附返回名附『"』）
                            ）
                        ）
                    ）
        ） 
            于（会异常而
                发生事故于异常附『「：换行：」在代码生成』附（表达式表示于式）附『时』
        ） 
        也。

        返回名
」
也。
「： 写引用于代码生成引用于代码生成。 ：」

代码生成顶层乃化字符串列而「：先前编译的全局模块名：」化表达式而字符串「：最终储存的全局变量名：」
                    合字符串「：模块开始的执行函数名：」
                    合字符串「：编译模块的源码：」也。
代码生成顶层者会先前模块路径名而会式而
    虑输出引用者新引用于【】而
    虑全局名者下个字符序数于『模块』而
    虑临时名者下个字符序数于『临时模块变量』而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑本次函数名者「代码生成」于写出于【】于式而
    虑全局函数名者下个字符序数于『模块初始化函数』而
    虑续延函数名者下个字符序数于『模块保存续延函数』而
    虑无者（写出于
        『define i64* @"』附续延函数名附『"(i64* "闭包", i64* "模块值"){「：换行：」』附
        『store i64* @"模块值", i64** @"』附全局名附『"「：换行：」』附
        空返回附『「：换行：」』附
        『}「：换行：」』附
        『define i64* @"』附全局函数名附『"(){「：换行：」』附
        『%"赋值续延函数包" = bitcast i64* (i64*, i64*)* @"』附续延函数名附『"「：换行：」』附
        『%"全局返回值" = call i64* @"』附本次函数名附『"(i64* %"赋值续延函数包")「：换行：」』附
        空返回附『「：换行：」』附
        『}』
        ）而
    虑先前模块全局名者（态射于（会路径而（读取代码生成信息于路径）中零）于先前模块路径名）而
    虑无者（态射于（会名而写出于『@"』附名附『" = external global i64*』）于先前模块全局名）而
    虑最终输出源码者默认编译模块的信息附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    （全局名）与全局函数名与最终输出源码
    也。