
寻观标准库之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树相等方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之模块操作之书。
寻观豫言编译器之编译数据之编译配置之编译期输出之书。

寻观豫言编译器之编译数据之抽象绑定树结构之命名环境术之书。

观抽象语法之书。
观抽象语法表示之书。

寻观豫言编译器之编译数据之操作符之操作符数据结构之书。
寻观豫言编译器之编译步骤之语法分析之函数合集之书。
寻观豫言编译器之编译步骤之类型检查之元变量管理之书。
寻观豫言编译器之编译步骤之类型检查之顶部归一化之书。
寻观拓展库之顺序标识符之顺序标识符之书。

寻观豫言编译器之编译数据之编译配置之编译期输出之书。
寻观豫言编译器之编译数据之文件管理之编译文件信息之书。
寻观豫言编译器之编译数据之抽象绑定树结构之静态单例类型处理之书。
寻观豫言编译器之编译步骤之总体过程之编译过程工具之书。

寻观代码生成工具之书。
寻观直接代码生成之书。
寻观豫言编译器之编译数据之编译配置之全局配置之书。


尾调用返回乃化字符串而字符串也。
尾调用返回者会名而
        『ret i64* %"』附名附『"』也。



代码生成乃化（化字符串而有）「：写全局文件：」
         而化字符串列「：当前所有的自由变量：」
         而化表达式「：待变换的式子：」
         而字符串「：生成的代码：」也。
代码生成者循「代码生成」以会写出而会已有自由变量而会式而
    虑「

        递归同变量者代码生成于写出于已有自由变量也。
        递归者代码生成于写出也。
        保留字段者下个字符序数于『_保留_』也。


        「： 返回名者下个字符序数于『生成函数』也。 ：」

        解绑乃承甲而化表达式而化（化字符串而化表达式而甲）而甲也。
        解绑者会式而会继续而
            虑名及后式者（解构抽象不重复名称于（更新可能绑定名于式）于已有自由变量）「：强制更新名称：」
            而继续于（名及后式中零）于（名及后式中一）也。



        已有声明参数签名者获取声明参数签名于（已有自由变量）也。

        「读名」者「读取直接变量」也。

        加载闭包乃化字符串「：闭包名：」而化字符串列「：加载的变量名：」而字符串「：以换行结尾的加载代码：」也。
        加载闭包者会闭包名而会自由变量名们而
                『%"闭包指针』附保留字段附『" = bitcast i64* %"』附闭包名附『" to i64** 「：换行：」』附
                （「串组合并」于（态射序号于（会序号而会变名而
                    『%"』附变名附『指针" = getelementptr i64*, i64** %"闭包指针』附保留字段附『", i64 』附（整数表示于序号）附『「：换行：」』附
                    『%"』附变名附『" = load i64*, i64** %"』附变名附『指针"「：换行：」』
                    ）于自由变量名们））也。
            。



        生成续延包并调用乃
              化字符串而「：本函数体一开始内容：」
              化表达式「：待变换的式子：」
              而化字符串「：最终调用的函数，会传入生成的续延：」
              而化字符串列「：最终调用的函数的参数，不包括传入的续延，会传入生成的续延：」
              而字符串也。
        生成续延包并调用者会开始内容而
                        会下个而会递归函数名而会参数名们而
            虑相关自由变量者（「移除重复」于「串相等」于（读取式自由变量于下个））而
            解绑于下个于（会后名而会后下个而
                            虑数组创建函数二者创建固定长度的数组于写出于（二）而
                            虑递归续延名者下个字符序数于『递归续延名』而
                            虑无者（写出于（「：续延闭包中所有的自由变量以及原先续延：」
                                    『define internal 』附默认调用规范附『 i64* @"』附递归续延名附『"(i64* %"续延函数闭包", i64* %"』附后名附『", i64* %"空续延占位") {「：换行：」』附
                                    （「加载闭包」于（『续延函数闭包』）于（相关自由变量接【续延函数名】））附
                                    （递归于（相关自由变量接【后名】）于后下个）附『「：换行：」』附
                                    『}』
                                ））而
                            虑数组创建函数者创建固定长度的数组于写出于（（长度于相关自由变量）加一）而
                            （（
                                    开始内容附
                                    『%"递归续延包』附保留字段附『" = call 』附默认调用规范附『 i64* @"』附（数组创建函数）附『"』附（获取声明参数签名于相关自由变量）附『「：换行：」』附
                                    『%"递归续延函数指针』附保留字段附『" = bitcast i64* (i64*, i64*, i64*)* @"』附（递归续延名）附『" to i64* 「：换行：」』附
                                    『%"递归续延』附保留字段附『" = call 』附默认调用规范附『 i64* @"』附（数组创建函数二）附『"』附（获取普通参数签名于【『递归续延函数指针』附保留字段，『递归续延包』附保留字段】）附『「：换行：」』附
                                    『%"』附（保留字段附『返回』）附『" = musttail call 』附默认调用规范附『 i64* 』附（递归函数名）附『』附（获取普通参数签名于（参数名们接【『递归续延』附保留字段】））附『「：换行：」』附
                                    （尾调用返回于（保留字段附『返回』））
                                ）
                        ）
                    ）也。


        续延返回乃化字符串而字符串也。
        续延返回者会串而
                （读取函数闭包函数值及闭包值于续延函数名于『i64* (i64*, i64*, i64*)』于（『函数值』附保留字段）于（『闭包值』附保留字段））附
                『%"默认返回值』附保留字段附『" = musttail call 』附默认调用规范附『 i64* %"函数值』附保留字段附『"(i64* %"闭包值』附保留字段附『", i64* %"』附串附『", i64* null)「：换行：」』附
            （尾调用返回于（『默认返回值』附保留字段））
            也。


        详细调试打印行于（会无而『代码生成中：』附（表达式表示于式））。

        转换结果乃字符串也。
        转换结果者
        尝试运行于（
            会无而
            鉴式而
                有（式节点于「内联虑」于「当前」衔「下个」衔【】）则
                    （解绑于下个于（会后名而会后下个而
                        （鉴当前而
                                    有（式节点于（闭包拉姆达抽象）于「双绑定」衔「闭包」衔【】）则
                                        （
                                            虑函数名者下个字符序数于（后名附『_函数』）而
                                            虑无者（解绑于双绑定于（会闭包名而会单绑定而
                                                解绑于单绑定于（会参数名而会函体而
                                                    （写出于
                                                        （包裹函数体于函数名于【闭包名， 参数名，续延函数名】于（
                                                            「递归」于【闭包名， 参数名】于函体
                                                        ））
                                                    ）
                                                ）
                                            ））而
                                            虑闭包名者读名于闭包而
                                            虑创建数组名者创建固定长度的数组于写出于二而「：优化！：」
                                            虑函数值名者下个字符序数于『函数值』而
                                            『%"』附函数值名附『" = bitcast i64* (i64*, i64*, i64*)* @"』附（函数名）附『" to i64*「：换行：」』附
                                            （『%"』附（后名）附『" = call 』附默认调用规范附『 i64* @"』附（创建数组名）附『"』附（获取普通参数签名于【函数值名，闭包名】））附『「：换行：」』附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ）
                                    或有（式节点于（拉姆达抽象三参数）于「三绑定」衔【】）则
                                    （
                                        虑函数名者下个字符序数于（后名附『_函数』）而
                                        虑无者（
                                            解绑于三绑定于（会闭包名而会双绑定而
                                                解绑于双绑定于（会参数名而会单绑定而
                                                    解绑于单绑定于（会续延函数名而会函体而
                                                        （写出于
                                                            （包裹函数体于函数名于【闭包名， 参数名，续延函数名】于（
                                                                「递归」于【闭包名， 参数名，续延函数名】于函体
                                                            ））
                                                        ）
                                                ）
                                            ）
                                        ））而
                                        『%"』附后名附『" = bitcast i64* (i64*, i64*, i64*)* @"』附（函数名）附『" to i64*「：换行：」』附
                                        （递归于（已有自由变量接【后名】）于后下个）
                                    ）
                                    或有（式节点于（函数调用三参数）于「函数」衔「参数一」衔「参数二」衔「参数三」衔【】）则
                                        （
                                            虑函数名者读名于函数而
                                            虑参数一名者读名于参数一而
                                            虑参数二名者读名于参数二而
                                            虑参数三名者读名于参数三而
                                            『%"函数指针』附保留字段附『" = bitcast i64* %"』附函数名附『" to i64* (i64*, i64*, i64*)*「：换行：」』附
                                            （『%"』附后名附『" = musttail call 』附默认调用规范附『 i64* %"函数指针』附（保留字段）附『"』附（获取普通参数签名于【参数一名，参数二名，参数三名】）附『「：换行：」』）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                            「： 鉴后下个而
                                                有（自由变量于名）则
                                                    （
                                                        若（「串相等」于名于后名）
                                                        则（
                                                        ）
                                                        否则（
                                                            发生事故于『尾调用返回名不符合』
                                                        ）
                                                    ）
                                                或有「其他」则
                                                    （
                                                        发生事故于『函数调用必须是尾调用，却得到了』附（表达式表示于式）
                                                    ） ：」
                                        ）
                                        或有（式节点于（闭包函数调用节点）于「函数」衔「参数」衔【】）则
                                        （
                                            虑函数名者读名于函数而
                                            虑参数名者读名于参数而
                                            生成续延包并调用于（
                                                读取函数闭包函数值及闭包值于函数名于『i64* (i64*, i64*, i64*)』于（『函数值』附保留字段）于（『闭包值』附保留字段）
                                            ）于下个于『%"函数值』附保留字段附『"』于【（『闭包值』附保留字段），参数名】
                                        ）
                                        或有（式节点于递归变量节点于「自变名」衔【】）则
                                        （
                                            虑递归变量名者读名于自变名而「：自变量是一个引用，指向一个值，这个值是一个Tuple，一个Tuple是一个指针，指向一个长度为2的数组：」
                                            生成续延包并调用于（
                                                    「： 『%"函数包指针引用』附保留字段附『" = bitcast i64* %"』附（递归变量名）附『" to i64**「：换行：」』附
                                                    『%"函数包指针』附保留字段附『" = load i64*, i64** %"函数包指针引用』附保留字段附『"「：换行：」』附
                                                    『%"空值』附保留字段附『" = bitcast i64* null to i64*「：换行：」』附 ：」
                                                    「： （读取函数闭包函数值及闭包值于（『函数包指针』附保留字段）于『i64* (i64*, i64*, i64*)』于（『函数值』附保留字段）于（『闭包值』附保留字段）） ：」
                                                    （读取函数闭包函数值及闭包值于（递归变量名）于『i64* (i64*, i64*, i64*)』于（『函数值』附保留字段）于（『闭包值』附保留字段））
                                            「： 于下个于『%"函数值』附保留字段附『"』于【（『闭包值』附保留字段），（『空值』附保留字段）】 ：」
                                            ）于下个于『%"函数值』附保留字段附『"』于【（『闭包值』附保留字段），（递归变量名）】
                                        ）
                                    或有「其他」则
                                        （
                                            
                                            （调试写于（会无而（表达式表示于当前）））附
                                            （「直接代码生成」于写出于后名于当前）附
                                            （递归于（已有自由变量接【后名】）于后下个）
                                        ））
                    ））
                
                或有（式节点于（爻分支节点）于「爻式」衔「阳式」衔「阴式」衔【】）则
                    （
                        虑爻式名者读名于爻式而
                        『%"』附保留字段附『爻" = ptrtoint i64* %"』附（爻式名）附『" to i1「：换行：」』附
                        『%"』附保留字段附『爻为真" = icmp ne i1 %"』附保留字段附『爻", 0「：换行：」』附
                        『br i1 %"』附保留字段附『爻为真", label %"』附保留字段附『真", label %"』附保留字段附『假"「：换行：」』附
                        『"』附保留字段附『真":「：换行：」』附
                        （递归同变量于阳式）附『「：换行：」』附
                        『"』附保留字段附『假":「：换行：」』附
                        （递归同变量于阴式）
                    ）

                或有（式节点于「闭包递归内联虑无类型」于「双绑定」衔「闭包」衔「下个」衔【】）则
                （
                    （
                        「： 虑递归函数引用名者下个字符序数于『递归函数引用』而 ：」
                        虑递归函数名者下个字符序数于『递归函数』而
                        虑空值名者下个字符序数于『空值』而
                        虑数组创建函数二者创建固定长度的数组于写出于（二）而
                        「： 虑无者（写出于『@"』附递归函数引用名附『" = internal global i64* null』）而 ：」
                        虑无者（解绑于双绑定于（会闭包名而会单绑定而
                            解绑于单绑定于（会递归绑定名而会函体而
                                    写出于（
                                        『define internal 』附默认调用规范附『 i64* @"』附（递归函数名）附『"』附（获取声明参数签名于【闭包名，递归绑定名】）附『 {「：换行：」』附
                                        「：『%"』附递归绑定名附『" = bitcast i64** @"』附（递归函数引用名）附『" to i64*「：换行：」』附：」
                                        （递归于【闭包名，递归绑定名】于函体）附『「：换行：」』附
                                        『}』
                                    ）
                            ）
                            ）
                        ）而
                        虑闭包名者读名于闭包而
                        生成续延包并调用
                            于（
                            『%"赋值递归函数值" = bitcast i64* (i64*, i64*, i64*)*  @"』附（递归函数名）附『" to i64*「：换行：」』附
                            「：『%"』附空值名附『" = bitcast i64* null to i64*「：换行：」』附：」
                            『%"赋值递归函数包" = call 』附默认调用规范附『 i64* @"』附（数组创建函数二）附『"』附（获取普通参数签名于【『赋值递归函数值』，闭包名】）附『「：换行：」』
                            「：『store i64* %"赋值递归函数包", i64** @"』附递归函数引用名附『"「：换行：」』：」
                            ）
                            于下个于『@"』附递归函数名附『"』于【闭包名，『赋值递归函数包』】
                        ）
                ）
                或有（式节点于模式匹配于「分析式」衔「分支们」）则
                    （
                        「：分支会被编译成当前自由变量加上被匹配的变量，分支自己加入更多的变量：」
                        虑分析名者读名于分析式而
                        虑分析式名者下个字符序数于『分析式』而
                            （虑「
                                处理分支乃化整数而化表达式列而字符串也。
                                处理分支者循处理分支以会数而会剩余分支们而
                                    鉴剩余分支们而
                                        有【】则（
                                            虑字符串内容者（『代码生成的模式匹配异常：』附（表达式表示于式））而
                                            虑字符串名者下个字符序数于『模式匹配异常字符串』而
                                            虑无者「添加外部调用」于『获取当前异常处理器』于（零）而
                                            虑无者写出于（字符串声明于字符串名于字符串内容）而
                                            『"分支』附（整数表示于数）附『』附保留字段附『":「：换行：」』附
                                            『%"当前异常处理函数包』附保留字段附『" = call i64* @"获取当前异常处理器"()「：换行：」』附
                                            （读取函数闭包函数值及闭包值于『当前异常处理函数包』附保留字段于『i64* (i64*, i64*)』于『函数值』附保留字段于『闭包值』附保留字段）附
                                            『%"字符串值』附保留字段附『" = bitcast 』附（字符串声明类型于字符串内容）附『* @"』附（字符串名）附『" to i64*「：换行：」』附
                                            『%"匹配失败返回』附保留字段附『" = tail call 』附默认调用规范附『 i64* %"函数值』附保留字段附『"(i64* %"闭包值』附保留字段附『", i64* %"字符串值』附保留字段附『")「：换行：」』附
                                            （尾调用返回于『匹配失败返回』附保留字段附『』）
                                        ）
                                        或有「当前」衔「剩余」则（
                                            「： 虑条件函数者编译模式匹配分支条件于写出于（获取模式匹配分支模式于当前）而 ：」
                                            『"分支』附（整数表示于数）附『』附保留字段附『":「：换行：」』附
                                            （鉴当前而
                                                「： 有（式节点于（模式匹配分支）于「模式」衔「结果」衔【】）则
                                                    （
                                                        『%"条件』附（整数表示于数）附『』附保留字段附『" = call i1 @"』附（条件函数）附『"(i64* %"』附分析式名附『")「：换行：」』附
                                                        『br i1 %"条件』附（整数表示于数）附『』附保留字段附『", label %"进入』附（整数表示于数）附『』附保留字段附『", label %"分支』附（整数表示于（数加一））附『』附保留字段附『"「：换行：」』
                                                    ）
                                                或 ：」
                                                有（式节点于（常量模式匹配分支）于「常量」衔「结果」衔【】）则
                                                    （
                                                        虑条件函数者编译模式匹配分支条件于写出于（「常量」）而
                                                        『%"条件』附（整数表示于数）附『』附保留字段附『" = call i1 @"』附（条件函数）附『"(i64* %"』附分析式名附『")「：换行：」』附
                                                        『br i1 %"条件』附（整数表示于数）附『』附保留字段附『", label %"进入』附（整数表示于数）附『』附保留字段附『", label %"分支』附（整数表示于（数加一））附『』附保留字段附『"「：换行：」』
                                                    ）
                                                或有（式节点于（唯一构造器模式匹配分支于「序数」）于「结果」衔【】）则
                                                    （
                                                        虑当前保留字段者下个字符序数于保留字段而
                                                        『%"构造器数组』附当前保留字段附『" = bitcast i64* %"』附分析式名附『" to i64*「：换行：」』附
                                                        『%"构造器指针』附当前保留字段附『" = getelementptr i64, i64* %"构造器数组』附当前保留字段附『", i64 0「：换行：」』附
                                                        『%"构造器』附当前保留字段附『" = load i64, i64* %"构造器指针』附当前保留字段附『"「：换行：」』附
                                                        『%"构造器匹配』附当前保留字段附『" = icmp eq i64 %"构造器』附当前保留字段附『", 』附（整数表示于序数）附『「：换行：」』附
                                                        『br i1 %"构造器匹配』附当前保留字段附『", label %"进入』附（整数表示于数）附『』附保留字段附『", label %"分支』附（整数表示于（数加一））附『』附保留字段附『"「：换行：」』
                                                    ）
                                                或有（式节点于（变量模式匹配分支）于「结果」衔【】）则
                                                    「：用于会成功：」
                                                    『br i1 1, label %"进入』附（整数表示于数）附『』附保留字段附『", label %"分支』附（整数表示于（数加一））附『』附保留字段附『"「：换行：」』
                                                或有「其他」则（发生事故于『生249：期待模式匹配分支，却得到了』附（表达式表示于当前））
                                            ）附『「：换行：」』附
                                            『"进入』附（整数表示于数）附『』附保留字段附『":「：换行：」』附
                                            （鉴当前而
                                                有（式节点于（模式匹配分支）于「模式」衔「结果」衔【】）则
                                                    （
                                                        虑新变量们者读取模式匹配新变量于模式而
                                                        虑新分析式名者下个字符序数于『分析式』而
                                                        虑分支函数名者分析式名附『_分支_』附（整数表示于数）附『_函数』而
                                                        虑闭包名者分析式名附『_分支_』附（整数表示于数）附『_豫言分支变量闭包』而
                                                        虑参数空名者分析式名附『_分支_』附（整数表示于数）附『_参数空名』而
                                                        虑无者写出于（包裹函数体于分支函数名于【闭包名，参数空名，续延函数名】于（
                                                            （「加载闭包」于闭包名于（已有自由变量接【分析式名】））附
                                                            『%"』附新分析式名附『" = bitcast i64* %"』附分析式名附『" to i64*「：换行：」』附
                                                            （编译模式匹配变量于写出于新分析式名于模式）附
                                                            （递归于（已有自由变量接新变量们）于结果）
                                                        ））而
                                                        虑数组创建函数者创建固定长度的数组于写出于（（长度于已有自由变量）加一）而
                                                        『%"』附闭包名附『" = call 』附默认调用规范附『 i64* @"』附（数组创建函数） 附『"』附（获取普通参数签名于（已有自由变量接【分析式名】））附『「：换行：」』附
                                                        『%"』附参数空名附『" = bitcast i64* null to i64*「：换行：」』附
                                                        『%"返回_分支』附（整数表示于数）附『』附保留字段附『" = musttail call 』附默认调用规范附『 i64* @"』附（分支函数名）附『"』附（获取声明参数签名于【闭包名，参数空名】）附『「：换行：」』附
                                                        （尾调用返回于『返回_分支』附（整数表示于数）附『』附保留字段附『』）
                                                    ）
                                                或有（式节点于（常量模式匹配分支）于「常量」衔「结果」衔【】）则
                                                    （
                                                        递归同变量于结果
                                                    ）
                                                或有（式节点于（唯一构造器模式匹配分支于「序数」）于「结果」衔【】）则
                                                    （
                                                        解绑于结果于（会绑定名而会后续而
                                                            虑当前保留字段者下个字符序数于保留字段而
                                                            『%"构造器数组』附当前保留字段附『" = bitcast i64* %"』附分析式名附『" to i64**「：换行：」』附
                                                            『%"构造器参数数组』附当前保留字段附『" = getelementptr i64*, i64** %"构造器数组』附当前保留字段附『", i64 1「：换行：」』附
                                                            『%"』附绑定名附『" = bitcast i64** %"构造器参数数组』附当前保留字段附『" to i64*「：换行：」』附
                                                            （递归于（已有自由变量接【绑定名】）于后续）
                                                        ）
                                                    ）
                                                或有（式节点于（变量模式匹配分支）于「结果」衔【】）则
                                                        递归同变量于（式替换于（自由变量于分析式名）于结果）
                                                或有「其他」则（发生事故于『生249：期待模式匹配分支，却得到了』附（表达式表示于当前））
                                            ）附『「：换行：」』附
                                            （处理分支于（数加一） 于剩余）
                                        ）也。
                                『%"』附分析式名附『" = bitcast i64* %"』附分析名附『" to i64*「：换行：」』附
                                『br label %"分支0』附保留字段附『"「：换行：」』附
                                （处理分支于零于分支们）
                            」）
                    ）
                或有（式节点于（续延调用节点）于「续参」衔【】）则（
                    解绑于续参于（会续延名而会续参体而
                        『%"』附（续延名）附『" = bitcast i64* %"』附续延函数名附『" to i64*「：换行：」』附
                        （递归于（已有自由变量接【续延名】）于续参体）
                    ）
                ）
                或有「其他」则
                    （
                        虑返回名者下个字符序数于『结果』而
                        （「直接代码生成」于写出于返回名于「其他」）
                        「： 附（续延返回于『』附返回名附『』） ：」
                        附（『ret i64* %"』附返回名附『"「：换行：」』）
                    ）
        ） 
            于（会异常而
                发生事故于异常附『「：换行：」在代码生成』附（表达式表示于式）附『时』
        ） 
        也。

        转换结果
」
也。
「： 写引用于代码生成引用于代码生成。 ：」
单个文件代码生成顶层乃化字符串列而「：先前编译的全局模块名：」
             化字符串而「：当前文件路径：」
             化字符串而「：全局名，需要声明存储：」
             化字符串而「：全局函数名：」
             化表达式而「：待变换式：」
             字符串「：编译模块的源码：」也。
单个文件代码生成顶层者会先前模块路径名而会当前路径而会全局名而会全局函数名而会式而
    虑输出引用者新引用于【】而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑无者（写出于
        『@"』附全局名附『" = global i64* null「：换行：」』附
        『define 』附默认调用规范附『 i64* @"』附全局函数名附『"(i64* %"保留名_目的是tailcall_1", i64* %"保留名_目的是tailcall_2", i64* %"保留名_目的是tailcall_3"){「：换行：」』附
        （「代码生成」于写出于【】于式）附
        『}』
        ）而
    虑无者（写出于
        （「串组合并」于（
            「串典态射」于（会名而会参数个数而
                『declare i64* @"』附（名）附『"(』附（
                        以『 ,』合并（打表于参数个数于（会序数而『i64*』）））附『)「：换行：」』
            ）于（读引用于「所有外部调用」）
        ））
    ）而
    虑无者（态射于（会路径而写出于
                    （虑先前全局名者（读取代码生成信息于路径）中零而
                        （调试写于（会无而路径））附『@"』附先前全局名附『" = external global i64*』）
                ）于先前模块路径名）而
    虑最终输出源码者（默认编译模块的信息于元）附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    最终输出源码
    也。 
「： 写引用于代码生成引用于代码生成。 ：」
「： 单个文件代码生成顶层乃化字符串列而「：先前编译的全局模块名：」
             化字符串而「：当前文件路径：」
             化字符串而「：全局函数名：」
             化表达式而「：待变换式：」
             字符串「：编译模块的源码：」也。
单个文件代码生成顶层者会先前模块路径名而会当前路径而会全局函数名而会式而
    虑输出引用者新引用于【】而
    虑模块标准名者去除路径结尾豫言拓展名于（路径之获取文件名于当前路径）而
    虑全局名者下个字符序数于模块标准名附『_模块』而
    虑临时名者下个字符序数于『临时模块变量』而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑本次函数名者下个字符序数于『本模块函数』而
    虑参数空名者下个字符序数于『参数空名』而
    虑闭包空名者下个字符序数于『闭包空名』而
    虑无者（写出于（包裹函数体于本次函数名于【闭包空名，参数空名，续延函数名】于（「代码生成」于写出于【】于式）））而
    虑全局函数名者下个字符序数于模块标准名附『_模块初始化函数』而
    虑续延函数名者下个字符序数于（模块标准名附『_模块保存续延函数』）而
    虑无者（写出于
        （「串组合并」于（
            「串典态射」于（会名而会参数个数而
                『declare i64* @"』附（名）附『"(』附（
                        以『 ,』合并（打表于参数个数于（会序数而『i64*』）））附『)「：换行：」』
            ）于（读引用于「所有外部调用」）
        ））
    ）而
    「：写全局的模块：」
    虑数组创建函数二者创建固定长度的数组于写出于（二）而
    虑无者（写出于
        『@"』附全局名附『" = global i64* null「：换行：」』附
        『define 』附默认调用规范附『 i64* @"』附续延函数名附『"(i64* "闭包", i64* %"模块值", i64* %"空续延值_顶层"){「：换行：」』附
        『store i64* %"模块值", i64** @"』附全局名附『"「：换行：」』附
        『ret i64* null「：换行：」』附
        『}「：换行：」』附
        『define 』附默认调用规范附『 i64* @"』附全局函数名附『"(){「：换行：」』附
        『%"赋值续延值" = bitcast i64* (i64*, i64*, i64*)* @"』附续延函数名附『" to i64*「：换行：」』附
        『%"赋值续延函数包" = call 』附默认调用规范附『 i64* @"』附数组创建函数二附『"(i64* %"赋值续延值", i64* null)「：换行：」』附
        『%"全局返回值" = call 』附默认调用规范附『 i64* @"』附本次函数名附『"(i64* null, i64* null, i64* %"赋值续延函数包")「：换行：」』附 「：这里不must musttail 因为这是入口函数：」
        （尾调用返回于『全局返回值』）附『「：换行：」』附
        『}』
        ）而
    虑无者（态射于（会路径而写出于
                    （虑先前全局名者（读取代码生成信息于路径）中零而
                        （调试写于（会无而路径））附『@"』附先前全局名附『" = external global i64*』）
                ）于先前模块路径名）而
    虑最终输出源码者（默认编译模块的信息于元）附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    （全局名）与全局函数名与最终输出源码
    也。  ：」

「：上个是单独文件编译，我们未来版本可能会用到，不过因为性能考虑，我们优先使用整体编译：」
可执行文件代码生成顶层乃
             化表达式而字符串「：编译模块的源码：」也。
可执行文件代码生成顶层者会式而
    虑输出引用者新引用于【】而
    虑模块标准名者下个字符序数于『总体模块』而
    虑全局名者下个字符序数于模块标准名附『_模块』而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑本次函数名者下个字符序数于『整体函数』而
    虑无者（写出于
        『@"』附全局名附『" = global i64* null「：换行：」』附
        『define 』附默认调用规范附『 i64* @"』附本次函数名附『"(i64* %"保留名_目的是tailcall_1", i64* %"保留名_目的是tailcall_2", i64* %"保留名_目的是tailcall_3"){「：换行：」』附
        （「代码生成」于写出于【】于式）附
        『}』
        ）而
    虑无者「添加外部调用」于『全局异常处理器』于三而
    虑无者（写出于
        （「串组合并」于（
            「串典态射」于（会名而会参数个数而
                『declare i64* @"』附（名）附『"(』附（
                        以『 ,』合并（打表于参数个数于（会序数而『i64*』）））附『)「：换行：」』
            ）于（读引用于「所有外部调用」）
        ））
    ）而
    「：写全局的模块：」
    虑无者（写出于
        『define 』附默认调用规范附『 i64* @"内部全局异常处理器"(i64* %"闭包", i64* %"错误值", i64* %"空续延值_顶层"){「：换行：」』附
        『%"默认值" = call i64* @"全局异常处理器"(i64* %"闭包", i64* %"错误值", i64* %"空续延值_顶层")「：换行：」』附
        『ret i64* null「：换行：」』附
        『}「：换行：」』附
        『define i64* @"entryMain"(){「：换行：」』附
        『%"全局返回值" = call 』附默认调用规范附『 i64* @"』附本次函数名附『"(i64* null, i64* null, i64* null)「：换行：」』附 「：这里不must musttail 因为这是入口函数：」
        （尾调用返回于『全局返回值』）附『「：换行：」』附
        『}』
        ）而
    虑最终输出源码者（默认编译模块的信息于元）附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    最终输出源码
    也。