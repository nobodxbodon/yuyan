「：This is untyped closure conversion. 
I have prepared groundwork for typed closure conversion, but I 
have not yet studied it.
：」



寻观标准库之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树相等方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之模块操作之书。
寻观豫言编译器之编译数据之编译配置之编译期输出之书。

寻观豫言编译器之编译数据之抽象绑定树结构之命名环境术之书。

观抽象语法之书。
观抽象语法表示之书。
观抽象语法相等之书。

寻观豫言编译器之编译数据之操作符之操作符数据结构之书。
寻观豫言编译器之编译步骤之语法分析之函数合集之书。
寻观豫言编译器之编译步骤之类型检查之元变量管理之书。
寻观豫言编译器之编译步骤之类型检查之顶部归一化之书。
寻观拓展库之顺序标识符之顺序标识符之书。

寻观豫言编译器之编译数据之编译配置之编译期输出之书。
寻观豫言编译器之编译数据之文件管理之编译文件信息之书。
寻观豫言编译器之编译数据之抽象绑定树结构之静态单例类型处理之书。

寻观代码生成工具之书。
寻观直接代码生成之书。
寻观豫言编译器之编译数据之编译配置之全局配置之书。

保留字段者『__豫言保留字段__』也。

空返回乃字符串也。
空返回者
    「：『%"零值" = inttoptr i64 0 to i64*「：换行：」』附：」
        『ret i64* null』也。

续延函数名者『豫言保留续延函数』也。


代码生成乃化（化字符串而有）「：写全局文件：」
         而化字符串列「：当前所有的自由变量：」
         而化表达式「：待变换的式子：」
         而字符串「：函数名，必须以自由变量调用：」也。
代码生成者循「代码生成」以会写出而会已有自由变量而会式而
    虑「

        递归同变量者代码生成于写出于已有自由变量也。
        递归者代码生成于写出也。


        返回名者下个字符序数于『生成函数』也。

        解绑乃承甲而化表达式而化（化字符串而化表达式而甲）而甲也。
        解绑者会式而会继续而
            虑名及后式者（解构抽象不重复名称于式于已有自由变量）
            而继续于（名及后式中零）于（名及后式中一）也。



        已有声明参数签名者获取声明参数签名于（已有自由变量）也。

        「读名」者读取自由变量也。


        包裹函数体乃化字符串而字符串也。
        包裹函数体者会串而『define internal i64* @"』附返回名附『"』附已有声明参数签名附『 {「：换行：」』附（串）附『「：换行：」}』也。

        生成续延包并调用乃
              化字符串而「：本函数体一开始内容：」
              「：递归续延需要写入的全局变量名，非递归请传可无：」
              「： 化（或可有字符串）而 ：」
              化表达式「：待变换的式子：」
              而化字符串「：最终调用的函数，会传入生成的续延：」
              而化字符串列「：最终调用的函数的参数，不包括传入的续延，会传入生成的续延：」
              而有也。
        生成续延包并调用者会开始内容而
                        「： 会可能全局名而 ：」
                        会下个而会递归函数名而会参数名们而
            解绑于下个于（会后名而会后下个而
                            虑数组创建函数二者创建固定长度的数组于写出于（二）而
                            虑下个函数者递归于（已有自由变量接【后名】）于后下个而
                            「： 虑续延开始内容者（
                                鉴「可能全局名」而有「可无」则『』
                                或有（可有全局名）则「：续延：第一个参数是闭包，第二个参数是返回值。递归：第一个参数是闭包，第二个参数是Kont：」
                                    （虑数组创建函数者创建固定长度的数组于写出于（（长度于已有自由变量））而
                                        『%"递归变量包" = call i64* @"』附（数组创建函数）附『"』附（获取普通参数签名于已有自由变量）附『「：换行：」』附
                                        『%"递归函数包" = call i64* @"』附（数组创建函数二）附『"』附（获取普通参数签名于【后名，『递归变量包』】）附『「：换行：」』附
                                        『store i64* %"递归函数包", i64** @"』附（全局名）附『"「：换行：」』
                                    ）
                            ）而 ：」
                            虑递归续延名者下个字符序数于『递归续延名』而
                            虑无者（写出于（「：续延闭包中所有的自由变量以及原先续延：」
                                    『define internal i64* @"』附递归续延名附『"(i64* %"续延函数闭包", i64* %"』附后名附『") {「：换行：」』附
                                    『%"续延函数闭包指针" = bitcast i64* %"续延函数闭包" to i64** 「：换行：」』附
                                    （「串组合并」于（态射序号于（会序号而会变名而
                                        『%"』附变名附『指针" = getelementptr i64*, i64** %"续延函数闭包指针", i64 』附（整数表示于序号）附『「：换行：」』附
                                        『%"』附变名附『" = load i64*, i64** %"』附变名附『指针"「：换行：」』
                                        ）于已有自由变量））附
                                    「： 续延开始内容附 ：」
                                    『%"原先续延指针" = getelementptr i64*, i64** %"续延函数闭包指针", i64 』附（整数表示于（长度于已有自由变量））附『「：换行：」』附
                                    『%"』附续延函数名附『" = load i64*, i64** %"原先续延指针"「：换行：」』附
                                    『%"最终结果』附保留字段附『" = call i64* @"』附（下个函数）附『"』附（获取声明参数签名于（已有自由变量接【后名】））附『「：换行：」』附
                                    （空返回）附『「：换行：」』附
                                    『}』
                                ））而
                            虑数组创建函数者创建固定长度的数组于写出于（（长度于已有自由变量）加一）而
                            （写出于
                                （包裹函数体于（
                                    开始内容附
                                    『%"递归续延包" = call i64* @"』附（数组创建函数）附『"』附已有声明参数签名附『「：换行：」』附
                                    『%"递归续延函数指针" = bitcast i64* (i64*, i64*)* @"』附（递归续延名）附『" to i64* 「：换行：」』附
                                    『%"递归续延" = call i64* @"』附（数组创建函数二）附『"』附（获取普通参数签名于【『递归续延函数指针』，『递归续延包』】）附『「：换行：」』附
                                    『%"』附（保留字段附『返回』）附『" = call i64* 』附（递归函数名）附『』附（获取普通参数签名于（参数名们接【『递归续延』】））附『「：换行：」』附
                                    （空返回）
                                ））
                        ）
                    ）也。


        续延返回乃化字符串而字符串也。
        续延返回者会串而
                （读取函数闭包函数值及闭包值于续延函数名于『i64* (i64*, i64*)』于『函数值』于『闭包值』）附
                「： 『%"函数包指针" = bitcast i64* %"』附（续延函数名）附『" to i64**「：换行：」』附
                『%"函数值指针" = getelementptr i64*, i64** %"函数包指针", i64 0「：换行：」』附
                『%"函数值值" = load i64*, i64** %"函数值指针"「：换行：」』附
                『%"函数值" = bitcast i64* %"函数值值" to i64* (i64*, i64*)*「：换行：」』附
                『%"闭包值指针" = getelementptr i64*, i64** %"函数包指针", i64 1「：换行：」』附
                『%"闭包值" = load i64*, i64** %"闭包值指针"「：换行：」』附 ：」
                『%"默认返回值" = call i64* %"函数值"(i64* %"闭包值", i64* %"』附串附『")「：换行：」』附
            「： （「直接代码生成」于写出于『默认返回值』于（式节点于（闭包函数调用节点）于【自由变量于（续延函数名），自由变量于串】））附 ：」
            （空返回）
            也。


        详细调试打印行于（会无而『代码生成中：』附（表达式表示于式））。

        转换结果乃有也。
        转换结果者
        尝试运行于（
            会无而
            鉴式而
                有（式节点于「内联虑」于当前衔下个衔【】）则
                    （解绑于下个于（会后名而会后下个而
                        （鉴当前而
                                    有（式节点于（闭包拉姆达抽象）于双绑定衔闭包衔【】）则
                                        （
                                            「： 虑函数名者下个字符序数于『函数』而 ：」
                                            虑函数名者（解绑于双绑定于（会闭包名而会单绑定而
                                                解绑于单绑定于（会参数名而会函体而
                                                    虑函体函数名者「递归」于【闭包名， 参数名】于函体而
                                                    函体函数名
                                                ）
                                            ））而
                                            虑闭包名者读名于闭包而
                                            虑创建数组名者创建固定长度的数组于写出于二而「：优化！：」
                                            虑下个函数者递归于（已有自由变量接【后名】）于后下个而
                                            （（写出于
                                                （包裹函数体于（
                                                『%"函数值" = bitcast i64* (i64*, i64*, i64*)* @"』附（函数名）附『" to i64*「：换行：」』附
                                                （『%"』附（后名）附『" = call i64* @"』附（创建数组名）附『"』附（获取普通参数签名于【『函数值』，闭包名】））附
                                                『%"后续" = call i64* @"』附（下个函数）附『"』附（获取声明参数签名于（已有自由变量接【后名】））附『「：换行：」』附
                                                （空返回）
                                                ）））
                                            ）
                                        ）
                                        或有（式节点于（闭包函数调用节点）于函数衔参数衔【】）则
                                        （
                                            虑函数名者读名于函数而
                                            虑参数名者读名于参数而
                                            生成续延包并调用于（
                                                读取函数闭包函数值及闭包值于函数名于『i64* (i64*, i64*, i64*)』于『函数值』于『闭包值』
                                                    「： 『%"函数包指针" = bitcast i64* %"』附（函数名）附『" to i64**「：换行：」』附
                                                    『%"函数值指针" = getelementptr i64*, i64** %"函数包指针", i64 0「：换行：」』附
                                                    『%"函数值值" = load i64*, i64** %"函数值指针"「：换行：」』附
                                                    『%"函数值" = bitcast i64* %"函数值值" to i64* (i64*, i64*, i64*)*「：换行：」』附
                                                    『%"闭包值指针" = getelementptr i64*, i64** %"函数包指针", i64 1「：换行：」』附
                                                    『%"闭包值" = load i64*, i64** %"闭包值指针"「：换行：」』 ：」
                                            ）于下个于『%"函数值"』于【『闭包值』，参数名】
                                        ）
                                        或有（式节点于递归变量节点于自变名衔【】）则
                                        （
                                            虑递归变量名者读名于自变名而「：自变量是一个引用，指向一个值，这个值是一个Tuple，一个Tuple是一个指针，指向一个长度为2的数组：」
                                            生成续延包并调用于（
                                                    『%"函数包指针引用" = bitcast i64* %"』附（递归变量名）附『" to i64**「：换行：」』附
                                                    『%"函数包指针" = load i64*, i64** %"函数包指针引用"「：换行：」』附
                                                    「：『%"函数包指针" = bitcast i64* %"』附（递归变量名）附『" to i64*「：换行：」』附：」
                                                    （读取函数闭包函数值及闭包值于『函数包指针』于『i64* (i64*, i64*)』于『函数值』于『闭包值』）
                                                    「： 『%"函数包指针数组" = bitcast i64* %"函数包指针" to i64**「：换行：」』附
                                                    『%"函数值指针" = getelementptr i64*, i64** %"函数包指针数组", i64 0「：换行：」』附
                                                    『%"函数值值" = load i64*, i64** %"函数值指针"「：换行：」』附
                                                    『%"函数值" = bitcast i64* %"函数值值" to i64* (i64*, i64*)*「：换行：」』附
                                                    『%"闭包值指针" = getelementptr i64*, i64** %"函数包指针数组", i64 1「：换行：」』附
                                                    『%"闭包值" = load i64*, i64** %"闭包值指针"「：换行：」』 ：」
                                            ）于下个于『%"函数值"』于【『闭包值』】
                                        ）
                                    或有「其他」则
                                        （
                                            虑下个函数者递归于（已有自由变量接【后名】）于后下个而
                                            
                                            （写出于
                                                （包裹函数体于（
                                                    （调试写于（会无而（表达式表示于当前）））附
                                                    （「直接代码生成」于写出于后名于当前）附
                                                    『%"后续" = call i64* @"』附（下个函数）附『"』附（获取声明参数签名于（已有自由变量接【后名】））附『「：换行：」』附
                                                    （空返回）
                                                ）））
                                        ））
                    ））
                
                或有（式节点于（爻分支节点）于爻式衔阳式衔阴式衔【】）则
                    （
                        虑爻式名者读名于爻式而
                        虑阳式函者递归同变量于阳式而
                        虑阴式函者递归同变量于阴式而
                        写出于（
                            包裹函数体于（
                                『%"』附保留字段附『爻" = ptrtoint i64* %"』附（爻式名）附『" to i1「：换行：」』附
                                『%"』附保留字段附『爻为真" = icmp ne i1 %"』附保留字段附『爻", 0「：换行：」』附
                                『br i1 %"』附保留字段附『爻为真", label %"』附保留字段附『真", label %"』附保留字段附『假"「：换行：」』附
                                『"』附保留字段附『真":「：换行：」』附
                                『%"』附保留字段附『真值" = call i64* @"』附（阳式函）附『"』附（已有声明参数签名）附『「：换行：」』附
                                『br label %"』附保留字段附『后"「：换行：」』附
                                『"』附保留字段附『假":「：换行：」』附
                                『%"』附保留字段附『假值" = call i64* @"』附（阴式函）附『"』附（已有声明参数签名）附『「：换行：」』附
                                『br label %"』附保留字段附『后"「：换行：」』附
                                『"』附保留字段附『后":「：换行：」』附「：其实这里不会执行，上述两个均不会返回：」
                                『%"』附保留字段附『结果值" = phi i64* [ %"』附保留字段附『真值", %"』附保留字段附『真" ], [ %"』附保留字段附『假值", %"』附保留字段附『假" ]「：换行：」』附
                                （空返回）
                            ）
                        ）
                    ）

                或有（式节点于「闭包递归内联虑无类型」于双绑定衔闭包衔下个衔【】）则
                （
                    （
                        虑递归函数引用名者下个字符序数于『递归函数引用』而
                        虑递归函数名者下个字符序数于『递归函数』而
                        虑数组创建函数二者创建固定长度的数组于写出于（二）而
                        虑无者（写出于『@"』附递归函数引用名附『" = internal global i64* null』）而
                        虑无者（解绑于双绑定于（会闭包名而会单绑定而
                            解绑于单绑定于（会递归绑定名而会函体而
                            「： 虑函体者式替换于（自由变量于递归函数名）于单绑定而 ：」
                                虑函体函数名者递归于【闭包名，递归绑定名】于函体而
                                    写出于（
                                        『define internal i64* @"』附（递归函数名）附『"』附（获取声明参数签名于【闭包名】）附『 {「：换行：」』附
                                        『%"递归函数引用" = bitcast i64** @"』附（递归函数引用名）附『" to i64*「：换行：」』附
                                        『%"返回值" = call i64* @"』附（函体函数名）附『"』附（获取声明参数签名于【闭包名，『递归函数引用』】）附『「：换行：」』附
                                        空返回附『「：换行：」』附
                                        『}』
                                    ）
                            ）
                            ）
                        ）而
                        虑闭包名者读名于闭包而
                        生成续延包并调用
                            于（
                            『%"赋值递归函数值" = bitcast i64* (i64*, i64*)*  @"』附（递归函数名）附『" to i64*「：换行：」』附
                            『%"赋值递归函数包" = call i64* @"』附（数组创建函数二）附『"』附（获取普通参数签名于【『赋值递归函数值』，闭包名】）附『「：换行：」』附
                            『store i64* %"赋值递归函数包", i64** @"』附递归函数引用名附『"「：换行：」』
                            「： 『%"未赋值递归函数值" = bitcast i64* (i64*, i64*)*  @"未赋值递归函数" to i64*「：换行：」』附
                            『%"空闭包" = inttoptr i64 0 to i64*「：换行：」』附
                            『%"未赋值递归函数包" = call i64* @"』附（数组创建函数二）附『"』附（获取普通参数签名于【『未赋值递归函数值』，『空闭包』】）附『「：换行：」』附
                            『store i64* %"未赋值递归函数包", i64** @"』附递归函数引用名附『"「：换行：」』 ：」
                            ）
                            「： 于（可有递归函数引用名）于下个于『@"』附递归函数名附『"』于【闭包名】 ：」
                            于下个于『@"』附递归函数名附『"』于【闭包名】
                        ）
                ）
                或有（式节点于模式匹配于分析式衔分支们）则
                    （
                        「：分支会被编译成当前自由变量加上被匹配的变量，分支自己加入更多的变量：」
                        虑分析名者读名于分析式而
                        虑分析式名者下个字符序数于『分析式』而
                        「： 虑新参数者获取参数签名于（已有自由变量接【『分析式』】）而 ：」
                        写出于（    
                            包裹函数体于（
                                （虑「
                                    处理分支乃化整数而化表达式列而字符串也。
                                    处理分支者循处理分支以会数而会剩余分支们而
                                        鉴剩余分支们而
                                            有【】则（
                                                虑字符串内容者（表达式表示于式）而
                                                虑字符串名者下个字符序数于『模式匹配异常字符串』而
                                                虑无者「添加外部调用」于『获取当前异常处理器』于（零）而
                                                虑无者写出于（字符串声明于字符串名于字符串内容）而
                                                『"分支』附（整数表示于数）附『":「：换行：」』附
                                                『%"当前异常处理函数包" = call i64* @"获取当前异常处理器"()「：换行：」』附
                                                （读取函数闭包函数值及闭包值于『当前异常处理函数包』于『i64* (i64*, i64*)』于『函数值』于『闭包值』）附
                                                「： 『%"函数包指针" = bitcast i64* %"当前异常处理函数包" to i64**「：换行：」』附
                                                『%"函数值指针" = getelementptr i64*, i64** %"函数包指针", i64 0「：换行：」』附
                                                『%"函数值值" = load i64*, i64** %"函数值指针"「：换行：」』附
                                                『%"函数值" = bitcast i64* %"函数值值" to i64* (i64*, i64*)*「：换行：」』附
                                                『%"闭包值指针" = getelementptr i64*, i64** %"函数包指针", i64 1「：换行：」』附
                                                『%"闭包值" = load i64*, i64** %"闭包值指针"「：换行：」』附 ：」
                                                『%"字符串值" = bitcast 』附（字符串声明类型于字符串内容）附『* @"』附（字符串名）附『" to i64*「：换行：」』附
                                                『%"返回" = call i64* %"函数值"(i64* %"闭包值", i64* %"字符串值")「：换行：」』附
                                                （空返回）
                                            ）
                                            或有（当前）衔剩余则（
                                                虑条件函数者编译模式匹配分支条件于写出于（获取模式匹配分支模式于当前）而
                                                虑执行函数者递归于（已有自由变量）于当前而
                                                『"分支』附（整数表示于数）附『":「：换行：」』附
                                                『%"条件』附（整数表示于数）附『" = call i1 @"』附（条件函数）附『"(i64* %"』附分析式名附『")「：换行：」』附
                                                『br i1 %"条件』附（整数表示于数）附『", label %"进入』附（整数表示于数）附『", label %"分支』附（整数表示于（数加一））附『"「：换行：」』附
                                                『"进入』附（整数表示于数）附『":「：换行：」』附
                                                『%"返回』附（整数表示于数）附『" = call i64* @"』附（执行函数）附『"』附（获取声明参数签名于（已有自由变量接【分析式名】））附『「：换行：」』附
                                                空返回附『「：换行：」』附
                                                （处理分支于（数加一） 于剩余）
                                            ）也。
                                    『%"』附分析式名附『" = bitcast i64* %"』附分析名附『" to i64*「：换行：」』附
                                    『br label %"分支0"「：换行：」』附
                                    （处理分支于零于分支们）
                                」）
                            ）
                        ）
                    ）
                或有（式节点于（模式匹配分支）于模式衔结果衔【】）则
                    （
                        「： 虑无者打印行于『218』而 ：」
                        虑新变量们者读取模式匹配新变量于模式而
                        「： 虑无者打印行于『210』而 ：」
                        虑结果函数者递归于（已有自由变量接新变量们）于结果而
                        「： 虑无者打印行于『410』而 ：」
                        虑分析式名者下个字符序数于『分析式』而
                        「： 虑无者打印行于『510』而 ：」
                        写出于（
                            『define i64* @"』附（返回名）附『"』附（获取声明参数签名于（已有自由变量接【分析式名】））附『 {「：换行：」』附
                            （编译模式匹配变量于写出于分析式名于模式）附
                            『%"返回值" = call i64* @"』附（结果函数）附『"』附（获取声明参数签名于（已有自由变量接新变量们））附『「：换行：」』附
                            空返回附『「：换行：」』附
                            『}』
                        ）
                    ）
                或有（式节点于（续延调用节点）于续参衔【】）则（
                    解绑于续参于（会续延名而会续参体而
                        虑续参体函者递归于（已有自由变量接【续延名】）于续参体而
                        写出于（
                            包裹函数体于（
                                『%"』附（续延名）附『" = bitcast i64* %"』附续延函数名附『" to i64*「：换行：」』附
                                『%"返回" = call i64* @"』附（续参体函）附『"』附（获取声明参数签名于（已有自由变量接【续延名】））附『「：换行：」』附
                                （空返回）
                            ）
                        ）
                    ）
                ）
                或有「其他」则
                    （
                        写出于（
                            包裹函数体于（
                                虑返回名者下个字符序数于『结果』而
                                （「直接代码生成」于写出于返回名于「其他」）
                                附（续延返回于『』附返回名附『』）
                            ）
                        ）
                    ）
        ） 
            于（会异常而
                发生事故于异常附『「：换行：」在代码生成』附（表达式表示于式）附『时』
        ） 
        也。

        返回名
」
也。
「： 写引用于代码生成引用于代码生成。 ：」

代码生成顶层乃化字符串列而「：先前编译的全局模块名：」化表达式而字符串「：最终储存的全局变量名：」
                    合字符串「：模块开始的执行函数名：」
                    合字符串「：编译模块的源码：」也。
代码生成顶层者会先前模块路径名而会式而
    虑输出引用者新引用于【】而
    虑全局名者下个字符序数于『模块』而
    虑临时名者下个字符序数于『临时模块变量』而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑本次函数名者「代码生成」于写出于【】于式而
    虑全局函数名者下个字符序数于『模块初始化函数』而
    虑续延函数名者下个字符序数于『模块保存续延函数』而
    虑无者（写出于
        （「串组合并」于（
            「串典态射」于（会名而会参数个数而
                『declare i64* @"』附（名）附『"(』附（
                        以『 ,』合并（打表于参数个数于（会序数而『i64*』）））附『)「：换行：」』
            ）于（读引用于「所有外部调用」）
        ））
    ）而
    「：写全局的模块：」
    虑数组创建函数二者创建固定长度的数组于写出于（二）而
    虑无者（写出于
        『@"』附全局名附『" = global i64* null「：换行：」』附
        『define i64* @"』附续延函数名附『"(i64* "闭包", i64* %"模块值"){「：换行：」』附
        『store i64* %"模块值", i64** @"』附全局名附『"「：换行：」』附
        空返回附『「：换行：」』附
        『}「：换行：」』附
        『define i64* @"』附全局函数名附『"(){「：换行：」』附
        『%"赋值续延值" = bitcast i64* (i64*, i64*)* @"』附续延函数名附『" to i64*「：换行：」』附
        『%"赋值续延函数包" = call i64* @"』附数组创建函数二附『"(i64* %"赋值续延值", i64* null)「：换行：」』附
        『%"全局返回值" = call i64* @"』附本次函数名附『"(i64* %"赋值续延函数包")「：换行：」』附
        空返回附『「：换行：」』附
        『}』
        ）而
    虑无者（态射于（会路径而写出于
                    （虑先前全局名者（读取代码生成信息于路径）中零而
                        （调试写于（会无而路径））附『@"』附先前全局名附『" = external global i64*』）
                ）于先前模块路径名）而
    虑最终输出源码者（默认编译模块的信息于元）附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    （全局名）与全局函数名与最终输出源码
    也。