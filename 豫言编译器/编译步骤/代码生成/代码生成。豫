「：This is untyped closure conversion. 
I have prepared groundwork for typed closure conversion, but I 
have not yet studied it.
：」



寻观标准库之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之抽象语法树相等方法之书。
寻观豫言编译器之编译数据之抽象绑定树结构之模块操作之书。
寻观豫言编译器之编译数据之编译配置之编译期输出之书。

寻观豫言编译器之编译数据之抽象绑定树结构之命名环境术之书。

观抽象语法之书。
观抽象语法表示之书。
观抽象语法相等之书。

寻观豫言编译器之编译数据之操作符之操作符数据结构之书。
寻观豫言编译器之编译步骤之语法分析之函数合集之书。
寻观豫言编译器之编译步骤之类型检查之元变量管理之书。
寻观豫言编译器之编译步骤之类型检查之顶部归一化之书。
寻观拓展库之顺序标识符之顺序标识符之书。

寻观豫言编译器之编译数据之编译配置之编译期输出之书。
寻观豫言编译器之编译数据之文件管理之编译文件信息之书。
寻观豫言编译器之编译数据之抽象绑定树结构之静态单例类型处理之书。

寻观代码生成工具之书。
寻观直接代码生成之书。


续延函数名者『豫言保留续延函数』也。

代码生成乃化（化字符串而有）「：写全局文件：」
         而化字符串列「：当前所有的自由变量：」
         而化表达式「：待变换的式子：」
         而字符串「：函数名，必须以自由变量调用：」也。
代码生成者循「代码生成」以会写出而会已有自由变量而会式而
    虑「

        递归同变量者代码生成于写出于已有自由变量也。
        递归者代码生成于写出也。


        返回名者下个字符序数于『生成函数』也。



        已有声明参数签名者获取声明参数签名于（已有自由变量）也。

        「读名」者读取自由变量也。


        包裹函数体乃化字符串而字符串也。
        包裹函数体者会串而『define internal i64* @"』附返回名附『"』附已有声明参数签名附『 {「：换行：」』附（串）附『「：换行：」}』也。

        默认返回乃化字符串而字符串也。
        「： 默认返回者会串而『ret 』附（默认指针类型）附『 』附串也。 ：」
        默认返回者会串而
            『%"默认返回值" = call i64* %"』附续延函数名附『"(i64* 』附串附『)「：换行：」』附
            『ret i64* %"默认返回值"』也。

        空写出乃化有而有也。
        空写出者会无而
            写出于（
                （包裹函数体于（
                    『%"空返回值" = inttoptr i64 0 to i64*「：换行：」』附
                    （默认返回于『%"空返回值"』）
                    ）
                ）
            ）也。

        详细调试打印行于（会无而『代码生成中：』附（表达式表示于式））。

        转换结果乃有也。
        转换结果者
        「： 尝试运行于 ：」
        「： 会无而 ：」
            鉴式而
                有（式节点于「内联虑」于当前衔下个衔【】）则
                    （解绑于下个于（会后名而会后下个而
                        （鉴当前而
                                    有（式节点于（闭包拉姆达抽象）于双绑定衔闭包衔【】）则
                                        （
                                            「： 虑函数名者下个字符序数于『函数』而 ：」
                                            虑函数名者（解绑于双绑定于（会闭包名而会单绑定而
                                                解绑于单绑定于（会参数名而会函体而
                                                    虑函体函数名者「递归」于【闭包名， 参数名】于函体而
                                                    函体函数名
                                                ）
                                            ））而
                                            虑闭包名者读名于闭包而
                                            虑创建数组名者创建固定长度的数组于写出于二而「：优化！：」
                                            虑下个函数者递归于（已有自由变量接【后名】）于后下个而
                                            （（写出于
                                                （包裹函数体于（
                                                『%"函数值" = bitcast i64* (i64*, i64*, i64* (i64*)*)* @"』附（函数名）附『" to i64*「：换行：」』附
                                                （『%"』附（后名）附『" = call i64* @"』附（创建数组名）附『"』附（获取普通参数签名于【『函数值』，闭包名】））附
                                                『%"后续" = call i64* @"』附（下个函数）附『"』附（获取声明参数签名于（已有自由变量接【后名】））附『「：换行：」』附
                                                （默认返回于（『%"后续"』））
                                                ）））
                                            ）
                                        ）
                                    或有「其他」则
                                        （
                                            虑下个函数者递归于（已有自由变量接【后名】）于后下个而
                                            
                                            （写出于
                                                （包裹函数体于（
                                                    （「直接代码生成」于写出于后名于当前）附
                                                    『%"后续" = call i64* @"』附（下个函数）附『"』附（获取声明参数签名于（已有自由变量接【后名】））附『「：换行：」』附
                                                    （默认返回于（『%"后续"』））
                                                ）））
                                        ））
                    ））
                
                或有（式节点于（爻分支节点）于爻式衔阳式衔阴式衔【】）则
                    （
                        虑爻式名者读名于爻式而
                        虑阳式函者递归同变量于阳式而
                        虑阴式函者递归同变量于阴式而
                        写出于（
                            包裹函数体于（
                                『%"爻" = ptrtoint i64* %"』附（爻式名）附『" to i1「：换行：」』附
                                『%"爻为真" = icmp ne i1 %"爻", 0「：换行：」』附
                                『br i1 %"爻为真", label %"真", label %"假"「：换行：」』附
                                『"真":「：换行：」』附
                                『%"真值" = call i64* @"』附（阳式函）附『"』附（已有声明参数签名）附『「：换行：」』附
                                『br label %"后"「：换行：」』附
                                『"假":「：换行：」』附
                                『%"假值" = call i64* @"』附（阴式函）附『"』附（已有声明参数签名）附『「：换行：」』附
                                『br label %"后"「：换行：」』附
                                『"后":「：换行：」』附「：其实这里不会执行，上述两个均不会返回：」
                                『%"结果值" = phi i64* [ %"真值", %"真" ], [ %"假值", %"假" ]「：换行：」』附
                                （默认返回于『%"结果值"』）
                            ）
                        ）
                    ）

                或有（式节点于「闭包递归内联虑无类型」于双绑定衔闭包衔下个衔【】）则
                （
                    （
                        虑递归函数名者下个字符序数于『递归函数』而
                        虑无者（解绑于双绑定于（会闭包名而会单绑定而
                            虑函体者式替换于（式节点于（递归函数待调用节点于递归函数名）于【自由变量于闭包名】）于单绑定而
                            虑函体函数名者递归于【闭包名】于函体而
                                写出于（
                                    『define internal i64* @"』附（递归函数名）附『"』附（获取声明参数签名于【闭包名】）附『 {「：换行：」』附
                                    『%"返回值" = call i64* @"』附（函体函数名）附『"』附（获取声明参数签名于【闭包名】）附『「：换行：」』附
                                    『ret i64* %"返回值"「：换行：」』附
                                    『}』
                                ）
                            ）
                        ）而
                        虑闭包名者读名于闭包而
                        解绑于下个于（会后名而会后下个而
                            虑下个函数者递归于（已有自由变量接【后名】）于后下个而
                            （写出于
                            （包裹函数体于（
                                『%"』附（后名）附『" = call i64* @"』附（递归函数名）附『"』附（获取调用参数签名于【闭包名】）附『「：换行：」』附
                                『%"后续" = call i64* @"』附（下个函数）附『"』附（获取调用参数签名于（已有自由变量接【后名】））附『「：换行：」』附
                                （默认返回于（『%"后续"』））
                            ））
                        ）
                    ））
                ）
                或有（式节点于模式匹配于分析式衔分支们）则
                    （
                        「：分支会被编译成当前自由变量加上被匹配的变量，分支自己加入更多的变量：」
                        虑分析式函者递归同变量于分析式而
                        「： 虑新参数者获取参数签名于（已有自由变量接【『分析式』】）而 ：」
                        写出于（    
                            包裹函数体于（
                                『%"分析式" = call i64* @"』附（分析式函）附『"』附（已有调用参数签名）附『「：换行：」』附
                                （虑「
                                    处理分支乃化整数而化表达式列而字符串也。
                                    处理分支者循处理分支以会数而会剩余分支们而
                                        鉴剩余分支们而
                                            有【】则（
                                                『分支』附（整数表示于数）附『:「：换行：」』附
                                                『%"返回" = call i64* yyThrowException(i64* 0)「：换行：」』附
                                                （默认返回于『%"返回"』）
                                            ）
                                            或有（当前）衔剩余则（
                                                虑条件函数者编译模式匹配分支条件于写出于当前而
                                                虑执行函数者递归于（已有自由变量接【『分析式』】）于当前而
                                                『分支』附（整数表示于数）附『:「：换行：」』附
                                                『%"条件" = call i1 @"』附（条件函数）附『"(i64* 分析式)「：换行：」』附
                                                『br i1 %"条件", label %"进入", label %"分支"』附（整数表示于（数加一））附『「：换行：」』附
                                                『进入:「：换行：」』附
                                                『%"返回" = call i64* @"』附（执行函数）附『"』附（获取调用参数签名于（已有自由变量接【『分析式』】））附『「：换行：」』附
                                                『ret i64* %"返回"』附『「：换行：」』附
                                                （处理分支于（数加一） 于剩余）
                                            ）也。
                                    处理分支于零于分支们
                                」）
                            ）
                        ）
                    ）
                或有（式节点于（模式匹配分支）于模式衔结果衔【】）则
                    （
                        虑新变量们者读取模式匹配新变量于模式而
                        虑结果函数者递归于（已有自由变量接新变量们）于模式而
                        虑分析式名者『分析式』而
                        写出于（
                            『def i64* @"』附（返回名）附『"』附（获取声明参数签名于（已有自由变量接【分析式名】））附『 {「：换行：」』附
                            （编译模式匹配变量于写出于分析式名于模式）附
                            『%"返回值" = call i64* @"』附（结果函数）附『"』附（获取调用参数签名于（已有自由变量接新变量们））附『「：换行：」』附
                            『ret i64* %"返回值"』附『「：换行：」』附
                            『}』
                        ）
                    ）
                或有「其他」则
                    （
                        写出于（
                            包裹函数体于（
                                虑返回名者下个字符串序数于『结果』而
                                「直接代码生成」于写出于返回名于「其他」
                                附（默认返回于『% "』附返回名附『"』）
                            ）
                        ）
                    ）
        「： 
            于（会异常而
                发生事故于异常附『「：换行：」在代码生成』附（表达式表示于式）附『时』
        ） ：」
        也。

        返回名
」
也。
「： 写引用于代码生成引用于代码生成。 ：」

代码生成顶层乃化字符串列而「：先前编译的全局模块名：」化表达式而字符串「：最终储存的全局变量名：」
                    合字符串「：模块开始的执行函数名：」
                    合字符串「：编译模块的源码：」也。
代码生成顶层者会先前模块路径名而会式而
    虑输出引用者新引用于【】而
    虑全局名者下个字符序数于『模块』而
    虑临时名者下个字符序数于『临时模块变量』而
    虑写出者（化字符串而有也（会新输出而（写引用于输出引用于（新输出衔（读引用于输出引用）））））而
    虑本次函数名者「代码生成」于写出于【】于式而
    虑全局函数名者下个字符序数于『模块初始化函数』而
    虑无者（写出于
        『define i64* @"』附全局函数名附『"(i64* (i64*)* %"』附续延函数名附『"){「：换行：」』附
        『%"全局返回值" = call i64* @"』附本次函数名附『"(i64* (i64*)* %"』附续延函数名附『")「：换行：」』附
        『ret i64* %"全局返回值"「：换行：」』附
        『}』
        ）而
    虑先前模块全局名者（态射于（会路径而（读取代码生成信息于路径）中零）于先前模块路径名）而
    虑无者（态射于（会名而写出于『@"』附名附『" = external global i64*』）于先前模块全局名）而
    虑最终输出源码者默认编译模块的信息附『「：换行：」』附（以『「：换行：」』合并（读引用于输出引用））而
    （全局名）与全局函数名与最终输出源码
    也。